(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('events'), require('keycon'), require('lodash-es'), require('@tmagic/core'), require('@tmagic/utils'), require('moveable-helper'), require('moveable'), require('@scena/guides')) :
  typeof define === 'function' && define.amd ? define(['exports', 'events', 'keycon', 'lodash-es', '@tmagic/core', '@tmagic/utils', 'moveable-helper', 'moveable', '@scena/guides'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.TMagicStage = {}, global.EventEmitter, global.KeyController, global.lodashEs, global.core, global.utils, global.MoveableHelper, global.Moveable, global.Guides));
})(this, (function (exports, EventEmitter, KeyController, lodashEs, core, utils, MoveableHelper, Moveable, Guides) { 'use strict';

  const GHOST_EL_ID_PREFIX = "ghost_el_";
  const DRAG_EL_ID_PREFIX = "drag_el_";
  const HIGHLIGHT_EL_ID_PREFIX = "highlight_el_";
  const CONTAINER_HIGHLIGHT_CLASS_NAME = "tmagic-stage-container-highlight";
  const PAGE_CLASS = "magic-ui-page";
  const DEFAULT_ZOOM = 1;
  var GuidesType = /* @__PURE__ */ ((GuidesType2) => {
    GuidesType2["HORIZONTAL"] = "horizontal";
    GuidesType2["VERTICAL"] = "vertical";
    return GuidesType2;
  })(GuidesType || {});
  var ZIndex = /* @__PURE__ */ ((ZIndex2) => {
    ZIndex2["MASK"] = "99999";
    ZIndex2["SELECTED_EL"] = "666";
    ZIndex2["GHOST_EL"] = "700";
    ZIndex2["DRAG_EL"] = "9";
    ZIndex2["HIGHLIGHT_EL"] = "8";
    return ZIndex2;
  })(ZIndex || {});
  var MouseButton = /* @__PURE__ */ ((MouseButton2) => {
    MouseButton2[MouseButton2["LEFT"] = 0] = "LEFT";
    MouseButton2[MouseButton2["MIDDLE"] = 1] = "MIDDLE";
    MouseButton2[MouseButton2["RIGHT"] = 2] = "RIGHT";
    return MouseButton2;
  })(MouseButton || {});
  var Mode = /* @__PURE__ */ ((Mode2) => {
    Mode2["ABSOLUTE"] = "absolute";
    Mode2["FIXED"] = "fixed";
    Mode2["SORTABLE"] = "sortable";
    return Mode2;
  })(Mode || {});
  const SELECTED_CLASS = "tmagic-stage-selected-area";

  const getParents = (el, relative) => {
    let cur = el.parentElement;
    const parents = [];
    while (cur && cur !== relative) {
      parents.push(cur);
      cur = cur.parentElement;
    }
    return parents;
  };
  const getOffset = (el) => {
    const htmlEl = el;
    const { offsetParent } = htmlEl;
    const left = htmlEl.offsetLeft || 0;
    const top = htmlEl.offsetTop || 0;
    if (offsetParent) {
      const parentOffset = getOffset(offsetParent);
      return {
        left: left + parentOffset.left,
        top: top + parentOffset.top
      };
    }
    return {
      left,
      top
    };
  };
  const getTargetElStyle = (el, zIndex) => {
    const offset = getOffset(el);
    const { transform } = getComputedStyle(el);
    return `
    position: absolute;
    transform: ${transform};
    left: ${offset.left}px;
    top: ${offset.top}px;
    width: ${el.clientWidth}px;
    height: ${el.clientHeight}px;
    ${typeof zIndex !== "undefined" ? `z-index: ${zIndex};` : ""}
  `;
  };
  const getAbsolutePosition = (el, { top, left }) => {
    const { offsetParent } = el;
    if (offsetParent) {
      const parentOffset = getOffset(offsetParent);
      return {
        left: left - parentOffset.left,
        top: top - parentOffset.top
      };
    }
    return { left, top };
  };
  const isAbsolute = (style) => style.position === "absolute";
  const isRelative = (style) => style.position === "relative";
  const isStatic = (style) => style.position === "static";
  const isFixed = (style) => style.position === "fixed";
  const isFixedParent = (el) => {
    let fixed = false;
    let dom = el;
    while (dom) {
      fixed = isFixed(getComputedStyle(dom));
      if (fixed) {
        break;
      }
      const { parentElement } = dom;
      if (!parentElement || parentElement.tagName === "BODY") {
        break;
      }
      dom = parentElement;
    }
    return fixed;
  };
  const getMode = (el) => {
    if (isFixedParent(el))
      return Mode.FIXED;
    const style = getComputedStyle(el);
    if (isStatic(style) || isRelative(style))
      return Mode.SORTABLE;
    return Mode.ABSOLUTE;
  };
  const getScrollParent = (element, includeHidden = false) => {
    let style = getComputedStyle(element);
    const overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/;
    if (isFixed(style))
      return null;
    for (let parent = element; parent.parentElement; ) {
      parent = parent.parentElement;
      if (parent.tagName === "HTML")
        return parent;
      style = getComputedStyle(parent);
      if (isAbsolute(style) && isStatic(style))
        continue;
      if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX))
        return parent;
    }
    return null;
  };
  const removeSelectedClassName = (doc) => {
    const oldEl = doc.querySelector(`.${SELECTED_CLASS}`);
    if (oldEl) {
      utils.removeClassName(oldEl, SELECTED_CLASS);
      if (oldEl.parentNode)
        utils.removeClassName(oldEl.parentNode, `${SELECTED_CLASS}-parent`);
      doc.querySelectorAll(`.${SELECTED_CLASS}-parents`).forEach((item) => {
        utils.removeClassName(item, `${SELECTED_CLASS}-parents`);
      });
    }
  };
  const addSelectedClassName = (el, doc) => {
    el.classList.add(SELECTED_CLASS);
    el.parentNode?.classList.add(`${SELECTED_CLASS}-parent`);
    getParents(el, doc.body).forEach((item) => {
      item.classList.add(`${SELECTED_CLASS}-parents`);
    });
  };
  const calcValueByFontsize = (doc, value) => {
    const { fontSize } = doc.documentElement.style;
    if (fontSize) {
      const times = globalThis.parseFloat(fontSize) / 100;
      return Number((value / times).toFixed(2));
    }
    return value;
  };
  const down = (deltaTop, target) => {
    let swapIndex = 0;
    let addUpH = target.clientHeight;
    const brothers = Array.from(target.parentNode?.children || []).filter(
      (node) => !node.id.startsWith(GHOST_EL_ID_PREFIX)
    );
    const index = brothers.indexOf(target);
    const downEls = brothers.slice(index + 1);
    for (let i = 0; i < downEls.length; i++) {
      const ele = downEls[i];
      if (ele.style?.position === "fixed") {
        continue;
      }
      addUpH += ele.clientHeight / 2;
      if (deltaTop <= addUpH) {
        break;
      }
      addUpH += ele.clientHeight / 2;
      swapIndex = i;
    }
    return {
      src: target.id,
      dist: downEls.length && swapIndex > -1 ? downEls[swapIndex].id : target.id
    };
  };
  const up = (deltaTop, target) => {
    const brothers = Array.from(target.parentNode?.children || []).filter(
      (node) => !node.id.startsWith(GHOST_EL_ID_PREFIX)
    );
    const index = brothers.indexOf(target);
    const upEls = brothers.slice(0, index);
    let addUpH = target.clientHeight;
    let swapIndex = upEls.length - 1;
    for (let i = upEls.length - 1; i >= 0; i--) {
      const ele = upEls[i];
      if (!ele)
        continue;
      if (ele.style.position === "fixed")
        continue;
      addUpH += ele.clientHeight / 2;
      if (-deltaTop <= addUpH)
        break;
      addUpH += ele.clientHeight / 2;
      swapIndex = i;
    }
    return {
      src: target.id,
      dist: upEls.length && swapIndex > -1 ? upEls[swapIndex].id : target.id
    };
  };
  const isMoveableButton = (target) => target.classList.contains("moveable-button") || target.parentElement?.classList.contains("moveable-button");

  class TargetShadow {
    el;
    els = [];
    idPrefix = "target_calibrate_";
    container;
    scrollLeft = 0;
    scrollTop = 0;
    zIndex;
    updateDragEl;
    constructor(config) {
      this.container = config.container;
      if (config.updateDragEl) {
        this.updateDragEl = config.updateDragEl;
      }
      if (typeof config.zIndex !== "undefined") {
        this.zIndex = config.zIndex;
      }
      if (config.idPrefix) {
        this.idPrefix = config.idPrefix;
      }
      this.container.addEventListener("customScroll", this.scrollHandler);
    }
    update(target) {
      this.el = this.updateEl(target, this.el);
      return this.el;
    }
    updateGroup(targetGroup) {
      if (this.els.length > targetGroup.length) {
        this.els.slice(targetGroup.length - 1).forEach((el) => {
          el.remove();
        });
      }
      this.els = targetGroup.map((target, index) => this.updateEl(target, this.els[index]));
      return this.els;
    }
    destroyEl() {
      this.el?.remove();
      this.el = void 0;
    }
    destroyEls() {
      this.els.forEach((el) => {
        el.remove();
      });
      this.els = [];
    }
    destroy() {
      this.container.removeEventListener("customScroll", this.scrollHandler);
      this.destroyEl();
      this.destroyEls();
    }
    updateEl(target, src) {
      const el = src || globalThis.document.createElement("div");
      el.id = `${this.idPrefix}${target.id}`;
      el.style.cssText = getTargetElStyle(target, this.zIndex);
      if (typeof this.updateDragEl === "function") {
        this.updateDragEl(el, target);
      }
      const isFixed = isFixedParent(target);
      const mode = this.container.dataset.mode || Mode.ABSOLUTE;
      if (isFixed && mode !== Mode.FIXED) {
        el.style.transform = `translate3d(${this.scrollLeft}px, ${this.scrollTop}px, 0)`;
      } else if (!isFixed && mode === Mode.FIXED) {
        el.style.transform = `translate3d(${-this.scrollLeft}px, ${-this.scrollTop}px, 0)`;
      }
      if (!globalThis.document.getElementById(el.id)) {
        this.container.append(el);
      }
      return el;
    }
    scrollHandler = (e) => {
      this.scrollLeft = e.detail.scrollLeft;
      this.scrollTop = e.detail.scrollTop;
    };
  }

  class DragResizeHelper {
    /** 目标节点在蒙层上的占位节点，用于跟鼠标交互，避免鼠标事件直接作用到目标节点 */
    targetShadow;
    /** 要操作的原始目标节点 */
    target;
    /** 多选:目标节点组 */
    targetList = [];
    /** 响应拖拽的状态事件，修改绝对定位布局下targetShadow的dom。
     * MoveableHelper里面的方法是成员属性，如果DragResizeHelper用继承的方式将无法通过super去调这些方法 */
    moveableHelper;
    /** 流式布局下，目标节点的镜像节点 */
    ghostEl;
    /** 用于记录节点被改变前的位置 */
    frameSnapShot = {
      left: 0,
      top: 0
    };
    /** 多选模式下的多个节点 */
    framesSnapShot = [];
    /** 布局方式：流式布局、绝对定位、固定定位 */
    mode = Mode.ABSOLUTE;
    constructor(config) {
      this.moveableHelper = MoveableHelper.create({
        useBeforeRender: true,
        useRender: false,
        createAuto: true
      });
      this.targetShadow = new TargetShadow({
        container: config.container,
        updateDragEl: config.updateDragEl,
        zIndex: ZIndex.DRAG_EL,
        idPrefix: DRAG_EL_ID_PREFIX
      });
    }
    destroy() {
      this.targetShadow.destroy();
      this.destroyGhostEl();
      this.moveableHelper.clear();
    }
    destroyShadowEl() {
      this.targetShadow.destroyEl();
    }
    getShadowEl() {
      return this.targetShadow.el;
    }
    updateShadowEl(el) {
      this.destroyGhostEl();
      this.target = el;
      this.targetShadow.update(el);
    }
    setMode(mode) {
      this.mode = mode;
    }
    /**
     * 改变大小事件开始
     * @param e 包含了拖拽节点的dom，moveableHelper会直接修改拖拽节点
     */
    onResizeStart(e) {
      this.moveableHelper.onResizeStart(e);
      this.frameSnapShot.top = this.target.offsetTop;
      this.frameSnapShot.left = this.target.offsetLeft;
    }
    onResize(e) {
      const { width, height, drag } = e;
      const { beforeTranslate } = drag;
      if (this.mode === Mode.SORTABLE) {
        this.target.style.top = "0px";
        if (this.targetShadow.el) {
          this.targetShadow.el.style.width = `${width}px`;
          this.targetShadow.el.style.height = `${height}px`;
        }
      } else {
        this.moveableHelper.onResize(e);
        this.target.style.left = `${this.frameSnapShot.left + beforeTranslate[0]}px`;
        this.target.style.top = `${this.frameSnapShot.top + beforeTranslate[1]}px`;
      }
      this.target.style.width = `${width}px`;
      this.target.style.height = `${height}px`;
    }
    onDragStart(e) {
      this.moveableHelper.onDragStart(e);
      if (this.mode === Mode.SORTABLE) {
        this.ghostEl = this.generateGhostEl(this.target);
      }
      this.frameSnapShot.top = this.target.offsetTop;
      this.frameSnapShot.left = this.target.offsetLeft;
    }
    onDrag(e) {
      if (this.ghostEl) {
        this.ghostEl.style.top = `${this.frameSnapShot.top + e.beforeTranslate[1]}px`;
        return;
      }
      this.moveableHelper.onDrag(e);
      this.target.style.left = `${this.frameSnapShot.left + e.beforeTranslate[0]}px`;
      this.target.style.top = `${this.frameSnapShot.top + e.beforeTranslate[1]}px`;
    }
    onRotateStart(e) {
      this.moveableHelper.onRotateStart(e);
    }
    onRotate(e) {
      this.moveableHelper.onRotate(e);
      const frame = this.moveableHelper.getFrame(e.target);
      this.target.style.transform = frame?.toCSSObject().transform || "";
    }
    onScaleStart(e) {
      this.moveableHelper.onScaleStart(e);
    }
    onScale(e) {
      this.moveableHelper.onScale(e);
      const frame = this.moveableHelper.getFrame(e.target);
      this.target.style.transform = frame?.toCSSObject().transform || "";
    }
    getGhostEl() {
      return this.ghostEl;
    }
    destroyGhostEl() {
      this.ghostEl?.remove();
      this.ghostEl = void 0;
    }
    clear() {
      this.moveableHelper.clear();
    }
    getFrame(el) {
      return this.moveableHelper.getFrame(el);
    }
    getShadowEls() {
      return this.targetShadow.els;
    }
    updateGroup(els) {
      this.targetList = els;
      this.framesSnapShot = [];
      this.targetShadow.updateGroup(els);
    }
    setTargetList(targetList) {
      this.targetList = targetList;
    }
    clearMultiSelectStatus() {
      this.targetList = [];
      this.targetShadow.destroyEls();
    }
    onResizeGroupStart(e) {
      const { events } = e;
      this.moveableHelper.onResizeGroupStart(e);
      this.setFramesSnapShot(events);
    }
    /**
     * 多选状态下通过拖拽边框改变大小，所有选中组件会一起改变大小
     */
    onResizeGroup(e) {
      const { events } = e;
      events.forEach((ev) => {
        const { width, height, beforeTranslate } = ev.drag;
        const frameSnapShot = this.framesSnapShot.find(
          (frameItem) => frameItem.id === ev.target.id.replace(DRAG_EL_ID_PREFIX, "")
        );
        if (!frameSnapShot)
          return;
        const targeEl = this.targetList.find(
          (targetItem) => targetItem.id === ev.target.id.replace(DRAG_EL_ID_PREFIX, "")
        );
        if (!targeEl)
          return;
        const isParentIncluded = this.targetList.find((targetItem) => targetItem.id === targeEl.parentElement?.id);
        if (!isParentIncluded) {
          targeEl.style.left = `${frameSnapShot.left + beforeTranslate[0]}px`;
          targeEl.style.top = `${frameSnapShot.top + beforeTranslate[1]}px`;
        }
        targeEl.style.width = `${width}px`;
        targeEl.style.height = `${height}px`;
      });
      this.moveableHelper.onResizeGroup(e);
    }
    onDragGroupStart(e) {
      const { events } = e;
      this.moveableHelper.onDragGroupStart(e);
      this.setFramesSnapShot(events);
    }
    onDragGroup(e) {
      const { events } = e;
      events.forEach((ev) => {
        const frameSnapShot = this.framesSnapShot.find(
          (frameItem) => frameItem.id === ev.target.id.replace(DRAG_EL_ID_PREFIX, "")
        );
        if (!frameSnapShot)
          return;
        const targeEl = this.targetList.find(
          (targetItem) => targetItem.id === ev.target.id.replace(DRAG_EL_ID_PREFIX, "")
        );
        if (!targeEl)
          return;
        const isParentIncluded = this.targetList.find((targetItem) => targetItem.id === targeEl.parentElement?.id);
        if (!isParentIncluded) {
          targeEl.style.left = `${frameSnapShot.left + ev.beforeTranslate[0]}px`;
          targeEl.style.top = `${frameSnapShot.top + ev.beforeTranslate[1]}px`;
        }
      });
      this.moveableHelper.onDragGroup(e);
    }
    getUpdatedElRect(el, parentEl, doc) {
      const offset = this.mode === Mode.SORTABLE ? { left: 0, top: 0 } : { left: el.offsetLeft, top: el.offsetTop };
      let left = calcValueByFontsize(doc, offset.left);
      let top = calcValueByFontsize(doc, offset.top);
      const width = calcValueByFontsize(doc, el.clientWidth);
      const height = calcValueByFontsize(doc, el.clientHeight);
      let shadowEl = this.getShadowEl();
      const shadowEls = this.getShadowEls();
      if (shadowEls.length) {
        shadowEl = shadowEls.find((item) => item.id.endsWith(el.id));
      }
      if (parentEl && this.mode === Mode.ABSOLUTE && shadowEl) {
        const targetShadowHtmlEl = shadowEl;
        const targetShadowElOffsetLeft = targetShadowHtmlEl.offsetLeft || 0;
        const targetShadowElOffsetTop = targetShadowHtmlEl.offsetTop || 0;
        const frame = this.getFrame(shadowEl);
        const [translateX, translateY] = frame?.properties.transform.translate.value;
        const { left: parentLeft, top: parentTop } = getOffset(parentEl);
        left = calcValueByFontsize(doc, targetShadowElOffsetLeft) + parseFloat(translateX) - calcValueByFontsize(doc, parentLeft);
        top = calcValueByFontsize(doc, targetShadowElOffsetTop) + parseFloat(translateY) - calcValueByFontsize(doc, parentTop);
      }
      return { width, height, left, top };
    }
    /**
     * 多选状态设置多个节点的快照
     */
    setFramesSnapShot(events) {
      if (this.framesSnapShot.length > 0)
        return;
      events.forEach((ev) => {
        const matchEventTarget = this.targetList.find(
          (targetItem) => targetItem.id === ev.target.id.replace(DRAG_EL_ID_PREFIX, "")
        );
        if (!matchEventTarget)
          return;
        this.framesSnapShot.push({
          left: matchEventTarget.offsetLeft,
          top: matchEventTarget.offsetTop,
          id: matchEventTarget.id
        });
      });
    }
    /**
     * 流式布局把目标节点复制一份进行拖拽，在拖拽结束前不影响页面原布局样式
     */
    generateGhostEl(el) {
      if (this.ghostEl) {
        this.destroyGhostEl();
      }
      const ghostEl = el.cloneNode(true);
      this.setGhostElChildrenId(ghostEl);
      const { top, left } = getAbsolutePosition(el, getOffset(el));
      ghostEl.id = `${GHOST_EL_ID_PREFIX}${el.id}`;
      ghostEl.style.zIndex = ZIndex.GHOST_EL;
      ghostEl.style.opacity = ".5";
      ghostEl.style.position = "absolute";
      ghostEl.style.left = `${left}px`;
      ghostEl.style.top = `${top}px`;
      el.after(ghostEl);
      return ghostEl;
    }
    setGhostElChildrenId(el) {
      for (const child of Array.from(el.children)) {
        if (child.id) {
          child.id = `${GHOST_EL_ID_PREFIX}${child.id}`;
        }
        if (child.children.length) {
          this.setGhostElChildrenId(child);
        }
      }
    }
  }

  const ableCss = ".moveable-button {\n  width: 20px;\n  height: 20px;\n  background: #4af;\n  border-radius: 4px;\n  appearance: none;\n  border: 0;\n  color: white;\n  font-size: 12px;\n  font-weight: bold;\n  margin-left: 2px;\n  position: relative;\n}\n.moveable-remove-button:before, .moveable-remove-button:after {\n  content: \"\";\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%) rotate(45deg);\n  width: 14px;\n  height: 2px;\n  background: #fff;\n  border-radius: 1px;\n  cursor: pointer;\n}\n.moveable-remove-button:after {\n  transform: translate(-50%, -50%) rotate(-45deg);\n}\n\n.moveable-select-parent-arrow-top-icon {\n  transform: rotateZ(-45deg);\n  width: 4px;\n  height: 4px;\n  border-color: #fff;\n  border-width: 2px 2px 0 0;\n  border-style: solid;\n  position: absolute;\n  left: 4px;\n  top: 4px;\n}\n\n.moveable-select-parent-arrow-body-icon {\n  width: 7px;\n  height: 11px;\n  border-color: #fff;\n  border-width: 0 0 2px 2px;\n  border-style: solid;\n}\n\n.moveable-drag-area-button {\n  cursor: move;\n}\n\n.moveable-drag-area-button .moveable-select-parent-arrow-top-icon {\n  width: 2px;\n  height: 2px;\n}\n\n.moveable-drag-area-button .moveable-select-parent-arrow-top-icon-top {\n  transform: rotateZ(-45deg) translateX(-50%);\n  left: 50%;\n  top: 3px;\n  transform-origin: left;\n}\n\n.moveable-drag-area-button .moveable-select-parent-arrow-top-icon-bottom {\n  transform: rotateZ(135deg) translateX(-50%);\n  transform-origin: left;\n  left: 50%;\n  top: auto;\n  bottom: 3px;\n}\n\n.moveable-drag-area-button .moveable-select-parent-arrow-top-icon-right {\n  transform: rotateZ(45deg)  translateY(-50%);\n  transform-origin: top;\n  right: 3px;\n  left: auto;\n  top: 50%;\n}\n\n.moveable-drag-area-button .moveable-select-parent-arrow-top-icon-left {\n  transform: rotateZ(235deg) translateY(-50%);\n  transform-origin: top;\n  left: 3px;\n  top: 50%;\n}\n\n.moveable-drag-area-button .moveable-select-parent-arrow-body-icon-horizontal {\n  width: 2px;\n  height: 11px;\n  background-color: #fff;\n  position: absolute;\n  transform: translateX(-50%);\n  left: 50%;\n  top: 4px;\n}\n\n.moveable-drag-area-button .moveable-select-parent-arrow-body-icon-vertical {\n  width: 11px;\n  height: 2px;\n  background-color: #fff;\n  position: absolute;\n  transform: translateY(-50%);\n  left: 4px;\n  top: 50%;;\n}\n\n";

  var ContainerHighlightType = /* @__PURE__ */ ((ContainerHighlightType2) => {
    ContainerHighlightType2["DEFAULT"] = "default";
    ContainerHighlightType2["ALT"] = "alt";
    return ContainerHighlightType2;
  })(ContainerHighlightType || {});
  var SelectStatus = /* @__PURE__ */ ((SelectStatus2) => {
    SelectStatus2["SELECT"] = "select";
    SelectStatus2["MULTI_SELECT"] = "multiSelect";
    return SelectStatus2;
  })(SelectStatus || {});
  var StageDragStatus = /* @__PURE__ */ ((StageDragStatus2) => {
    StageDragStatus2["START"] = "start";
    StageDragStatus2["ING"] = "ing";
    StageDragStatus2["END"] = "end";
    return StageDragStatus2;
  })(StageDragStatus || {});
  var AbleActionEventType = /* @__PURE__ */ ((AbleActionEventType2) => {
    AbleActionEventType2["SELECT_PARENT"] = "select-parent";
    AbleActionEventType2["REMOVE"] = "remove";
    return AbleActionEventType2;
  })(AbleActionEventType || {});

  const MoveableActionsAble = (handler) => ({
    name: "actions",
    props: [],
    events: [],
    render(moveable, React) {
      const rect = moveable.getRect();
      const { pos2 } = moveable.state;
      const editableViewer = moveable.useCSS(
        "div",
        `
      {
        position: absolute;
        left: 0px;
        top: 0px;
        will-change: transform;
        transform-origin: 0px 0px;
        display: flex;
      }
      ${ableCss}
      `
      );
      return React.createElement(
        editableViewer,
        {
          className: "moveable-editable",
          style: {
            transform: `translate(${pos2[0] - 60}px, ${pos2[1] - 28}px) rotate(${rect.rotation}deg)`
          }
        },
        [
          React.createElement(
            "button",
            {
              className: "moveable-button",
              title: "选中父组件",
              onClick: () => {
                handler(AbleActionEventType.SELECT_PARENT);
              }
            },
            React.createElement("div", {
              className: "moveable-select-parent-arrow-top-icon"
            }),
            React.createElement("div", {
              className: "moveable-select-parent-arrow-body-icon"
            })
          ),
          React.createElement("button", {
            className: "moveable-button moveable-remove-button",
            title: "删除",
            onClick: () => {
              handler(AbleActionEventType.REMOVE);
            }
          }),
          React.createElement(
            "button",
            {
              className: "moveable-button moveable-drag-area-button",
              title: "拖动"
            },
            React.createElement("div", {
              className: "moveable-select-parent-arrow-top-icon moveable-select-parent-arrow-top-icon-top"
            }),
            React.createElement("div", {
              className: "moveable-select-parent-arrow-top-icon moveable-select-parent-arrow-top-icon-bottom"
            }),
            React.createElement("div", {
              className: "moveable-select-parent-arrow-top-icon moveable-select-parent-arrow-top-icon-left"
            }),
            React.createElement("div", {
              className: " moveable-select-parent-arrow-top-icon moveable-select-parent-arrow-top-icon-right"
            }),
            React.createElement("div", {
              className: "moveable-select-parent-arrow-body-icon-horizontal"
            }),
            React.createElement("div", {
              className: "moveable-select-parent-arrow-body-icon-vertical"
            })
          )
        ]
      );
    }
  });

  class MoveableOptionsManager extends EventEmitter {
    /** 布局方式：流式布局、绝对定位、固定定位 */
    mode = Mode.ABSOLUTE;
    /** 画布容器 */
    container;
    options = {};
    /** 水平参考线 */
    horizontalGuidelines = [];
    /** 垂直参考线 */
    verticalGuidelines = [];
    /** 对齐元素集合 */
    elementGuidelines = [];
    /** 由外部调用方（编辑器）传入进来的moveable默认参数，可以为空，也可以是一个回调函数 */
    customizedOptions;
    /** 获取整个画布的根元素（在StageCore的mount函数中挂载的container） */
    getRootContainer;
    constructor(config) {
      super();
      this.customizedOptions = config.moveableOptions;
      this.container = config.container;
      this.getRootContainer = config.getRootContainer;
    }
    getOption(key) {
      return this.options[key];
    }
    /**
     * 设置水平/垂直参考线
     * @param type 参考线类型
     * @param guidelines 参考线坐标数组
     */
    setGuidelines(type, guidelines) {
      if (type === GuidesType.HORIZONTAL) {
        this.horizontalGuidelines = guidelines;
      } else if (type === GuidesType.VERTICAL) {
        this.verticalGuidelines = guidelines;
      }
      this.emit("update-moveable");
    }
    /**
     * 清除横向和纵向的参考线
     */
    clearGuides() {
      this.horizontalGuidelines = [];
      this.verticalGuidelines = [];
      this.emit("update-moveable");
    }
    /**
     * 设置有哪些元素要辅助对齐
     * @param selectedElList 选中的元素列表，需要排除在对齐元素之外
     * @param allElList 全部元素列表
     */
    setElementGuidelines(selectedElList, allElList) {
      this.elementGuidelines.forEach((node) => {
        node.remove();
      });
      this.elementGuidelines = [];
      if (this.mode === Mode.ABSOLUTE) {
        this.container.append(this.createGuidelineElements(selectedElList, allElList));
      }
    }
    /**
     * 获取moveable参数
     * @param isMultiSelect 是否多选模式
     * @param runtimeOptions 调用时实时传进来的的moveable参数
     * @returns moveable所需参数
     */
    getOptions(isMultiSelect, runtimeOptions = {}) {
      const defaultOptions = this.getDefaultOptions(isMultiSelect);
      const customizedOptions = this.getCustomizeOptions();
      this.options = lodashEs.merge(defaultOptions, customizedOptions, runtimeOptions);
      return this.options;
    }
    /**
     * 获取单选和多选的moveable公共参数
     * @returns moveable公共参数
     */
    getDefaultOptions(isMultiSelect) {
      const isSortable = this.mode === Mode.SORTABLE;
      const commonOptions = {
        draggable: true,
        resizable: true,
        rootContainer: this.getRootContainer(),
        zoom: 1,
        throttleDrag: 0,
        snappable: true,
        horizontalGuidelines: this.horizontalGuidelines,
        verticalGuidelines: this.verticalGuidelines,
        elementGuidelines: this.elementGuidelines,
        bounds: {
          top: 0,
          left: 0,
          right: this.container.clientWidth,
          bottom: isSortable ? void 0 : this.container.clientHeight
        }
      };
      const differenceOptions = isMultiSelect ? this.getMultiOptions() : this.getSingleOptions();
      return lodashEs.merge(commonOptions, differenceOptions);
    }
    /**
     * 获取单选下的差异化参数
     * @returns {MoveableOptions} moveable options参数
     */
    getSingleOptions() {
      const isAbsolute = this.mode === Mode.ABSOLUTE;
      const isFixed = this.mode === Mode.FIXED;
      return {
        origin: false,
        dragArea: false,
        scalable: false,
        rotatable: false,
        snapGap: isAbsolute || isFixed,
        snapThreshold: 5,
        snapDigit: 0,
        isDisplaySnapDigit: isAbsolute,
        snapDirections: {
          top: isAbsolute,
          right: isAbsolute,
          bottom: isAbsolute,
          left: isAbsolute,
          center: isAbsolute,
          middle: isAbsolute
        },
        elementSnapDirections: {
          top: isAbsolute,
          right: isAbsolute,
          bottom: isAbsolute,
          left: isAbsolute
        },
        isDisplayInnerSnapDigit: true,
        dragTarget: ".moveable-drag-area-button",
        dragTargetSelf: true,
        props: {
          actions: true
        },
        ables: [MoveableActionsAble(this.actionHandler.bind(this))]
      };
    }
    /**
     * 获取多选下的差异化参数
     * @returns {MoveableOptions} moveable options参数
     */
    getMultiOptions() {
      return {
        defaultGroupRotate: 0,
        defaultGroupOrigin: "50% 50%",
        startDragRotate: 0,
        throttleDragRotate: 0,
        origin: true,
        padding: { left: 0, top: 0, right: 0, bottom: 0 }
      };
    }
    /**
     * 获取业务方自定义的moveable参数
     */
    getCustomizeOptions() {
      if (typeof this.customizedOptions === "function") {
        return this.customizedOptions();
      }
      return this.customizedOptions;
    }
    /**
     * 这是给selectParentAbles的回调函数，用于触发选中父元素事件
     */
    actionHandler(type) {
      this.emit(type);
    }
    /**
     * 为需要辅助对齐的元素创建div
     * @param selectedElList 选中的元素列表，需要排除在对齐元素之外
     * @param allElList 全部元素列表
     * @returns frame 辅助对齐元素集合的页面片
     */
    createGuidelineElements(selectedElList, allElList) {
      const frame = globalThis.document.createDocumentFragment();
      for (const node of allElList) {
        const { width, height } = node.getBoundingClientRect();
        if (this.isInElementList(node, selectedElList))
          continue;
        const { left, top } = getOffset(node);
        const elementGuideline = globalThis.document.createElement("div");
        elementGuideline.style.cssText = `position: absolute;width: ${width}px;height: ${height}px;top: ${top}px;left: ${left}px`;
        this.elementGuidelines.push(elementGuideline);
        frame.append(elementGuideline);
      }
      return frame;
    }
    /**
     * 判断一个元素是否在元素列表里面
     * @param ele 元素
     * @param eleList 元素列表
     * @returns 是否在元素列表里面
     */
    isInElementList(ele, eleList) {
      for (const eleItem of eleList) {
        if (ele === eleItem)
          return true;
      }
      return false;
    }
  }

  class StageDragResize extends MoveableOptionsManager {
    /** 目标节点 */
    target;
    /** Moveable拖拽类实例 */
    moveable;
    /** 拖动状态 */
    dragStatus = StageDragStatus.END;
    dragResizeHelper;
    disabledDragStart;
    getRenderDocument;
    markContainerEnd;
    delayedMarkContainer;
    constructor(config) {
      super(config);
      this.getRenderDocument = config.getRenderDocument;
      this.markContainerEnd = config.markContainerEnd;
      this.delayedMarkContainer = config.delayedMarkContainer;
      this.disabledDragStart = config.disabledDragStart;
      this.dragResizeHelper = config.dragResizeHelper;
      this.on("update-moveable", () => {
        if (this.moveable) {
          this.updateMoveable();
        }
      });
    }
    getTarget() {
      return this.target;
    }
    /**
     * 将选中框渲染并覆盖到选中的组件Dom节点上方
     * 当选中的节点不是absolute时，会创建一个新的节点出来作为拖拽目标
     * @param el 选中组件的Dom节点元素
     * @param event 鼠标事件
     */
    select(el, event) {
      if (!this.moveable || el !== this.target) {
        this.initMoveable(el);
      } else {
        this.updateMoveable(el);
      }
      if (event && !this.disabledDragStart) {
        this.moveable?.dragStart(event);
      }
    }
    /**
     * 初始化选中框并渲染出来
     */
    updateMoveable(el = this.target) {
      if (!this.moveable)
        return;
      if (!el)
        throw new Error("未选中任何节点");
      const options = this.init(el);
      Object.entries(options).forEach(([key, value]) => {
        this.moveable[key] = value;
      });
      this.moveable.updateRect();
    }
    clearSelectStatus() {
      if (!this.moveable)
        return;
      this.dragResizeHelper.destroyShadowEl();
      this.moveable.target = null;
      this.moveable.updateRect();
    }
    getDragStatus() {
      return this.dragStatus;
    }
    /**
     * 销毁实例
     */
    destroy() {
      this.moveable?.destroy();
      this.dragResizeHelper.destroy();
      this.dragStatus = StageDragStatus.END;
      this.removeAllListeners();
    }
    init(el) {
      if (/(auto|scroll)/.test(el.style.overflow)) {
        el.style.overflow = "hidden";
      }
      this.target = el;
      this.mode = getMode(el);
      this.dragResizeHelper.updateShadowEl(el);
      this.dragResizeHelper.setMode(this.mode);
      const elementGuidelines = Array.prototype.slice.call(this.target?.parentElement?.children) || [];
      this.setElementGuidelines([this.target], elementGuidelines);
      return this.getOptions(false, {
        target: this.dragResizeHelper.getShadowEl()
      });
    }
    initMoveable(el) {
      const options = this.init(el);
      this.dragResizeHelper.clear();
      this.moveable?.destroy();
      this.moveable = new Moveable(this.container, {
        ...options
      });
      this.bindResizeEvent();
      this.bindDragEvent();
      this.bindRotateEvent();
      this.bindScaleEvent();
    }
    bindResizeEvent() {
      if (!this.moveable)
        throw new Error("moveable 未初始化");
      this.moveable.on("resizeStart", (e) => {
        if (!this.target)
          return;
        this.dragStatus = StageDragStatus.START;
        this.dragResizeHelper.onResizeStart(e);
      }).on("resize", (e) => {
        if (!this.moveable || !this.target || !this.dragResizeHelper.getShadowEl())
          return;
        this.dragStatus = StageDragStatus.ING;
        this.dragResizeHelper.onResize(e);
      }).on("resizeEnd", () => {
        this.dragStatus = StageDragStatus.END;
        this.update(true);
      });
    }
    bindDragEvent() {
      if (!this.moveable)
        throw new Error("moveable 未初始化");
      let timeout;
      this.moveable.on("dragStart", (e) => {
        if (!this.target)
          throw new Error("未选中组件");
        this.dragStatus = StageDragStatus.START;
        this.dragResizeHelper.onDragStart(e);
        this.emit("drag-start", e);
      }).on("drag", (e) => {
        if (!this.target || !this.dragResizeHelper.getShadowEl())
          return;
        if (timeout) {
          globalThis.clearTimeout(timeout);
          timeout = void 0;
        }
        timeout = this.delayedMarkContainer(e.inputEvent, [this.target]);
        this.dragStatus = StageDragStatus.ING;
        this.dragResizeHelper.onDrag(e);
      }).on("dragEnd", () => {
        if (timeout) {
          globalThis.clearTimeout(timeout);
          timeout = void 0;
        }
        const parentEl = this.markContainerEnd();
        if (this.dragStatus === StageDragStatus.ING) {
          if (parentEl) {
            this.update(false, parentEl);
          } else {
            switch (this.mode) {
              case Mode.SORTABLE:
                this.sort();
                break;
              default:
                this.update();
            }
          }
        }
        this.dragStatus = StageDragStatus.END;
        this.dragResizeHelper.destroyGhostEl();
      });
    }
    bindRotateEvent() {
      if (!this.moveable)
        throw new Error("moveable 未初始化");
      this.moveable.on("rotateStart", (e) => {
        this.dragStatus = StageDragStatus.START;
        this.dragResizeHelper.onRotateStart(e);
      }).on("rotate", (e) => {
        if (!this.target || !this.dragResizeHelper.getShadowEl())
          return;
        this.dragStatus = StageDragStatus.ING;
        this.dragResizeHelper.onRotate(e);
      }).on("rotateEnd", (e) => {
        this.dragStatus = StageDragStatus.END;
        const frame = this.dragResizeHelper?.getFrame(e.target);
        this.emit("update", {
          data: [
            {
              el: this.target,
              style: {
                transform: frame?.get("transform")
              }
            }
          ]
        });
      });
    }
    bindScaleEvent() {
      if (!this.moveable)
        throw new Error("moveable 未初始化");
      this.moveable.on("scaleStart", (e) => {
        this.dragStatus = StageDragStatus.START;
        this.dragResizeHelper.onScaleStart(e);
      }).on("scale", (e) => {
        if (!this.target || !this.dragResizeHelper.getShadowEl())
          return;
        this.dragStatus = StageDragStatus.ING;
        this.dragResizeHelper.onScale(e);
      }).on("scaleEnd", (e) => {
        this.dragStatus = StageDragStatus.END;
        const frame = this.dragResizeHelper.getFrame(e.target);
        this.emit("update", {
          data: [
            {
              el: this.target,
              style: {
                transform: frame?.get("transform")
              }
            }
          ]
        });
      });
    }
    sort() {
      if (!this.target || !this.dragResizeHelper.getGhostEl())
        throw new Error("未知错误");
      const { top } = this.dragResizeHelper.getGhostEl().getBoundingClientRect();
      const { top: oriTop } = this.target.getBoundingClientRect();
      const deltaTop = top - oriTop;
      if (Math.abs(deltaTop) >= this.target.clientHeight / 2) {
        if (deltaTop > 0) {
          this.emit("sort", down(deltaTop, this.target));
        } else {
          this.emit("sort", up(deltaTop, this.target));
        }
      } else {
        this.emit("sort", {
          src: this.target.id,
          dist: this.target.id
        });
      }
    }
    update(isResize = false, parentEl = null) {
      if (!this.target)
        return;
      const doc = this.getRenderDocument();
      if (!doc)
        return;
      const rect = this.dragResizeHelper.getUpdatedElRect(this.target, parentEl, doc);
      this.emit("update", {
        data: [
          {
            el: this.target,
            style: isResize ? rect : { left: rect.left, top: rect.top }
          }
        ],
        parentEl
      });
    }
  }

  class StageHighlight extends EventEmitter.EventEmitter {
    container;
    target;
    moveable;
    targetShadow;
    getRootContainer;
    constructor(config) {
      super();
      this.container = config.container;
      this.getRootContainer = config.getRootContainer;
      this.targetShadow = new TargetShadow({
        container: config.container,
        updateDragEl: config.updateDragEl,
        zIndex: ZIndex.HIGHLIGHT_EL,
        idPrefix: HIGHLIGHT_EL_ID_PREFIX
      });
    }
    /**
     * 高亮鼠标悬停的组件
     * @param el 选中组件的Dom节点元素
     */
    highlight(el) {
      if (!el || el === this.target)
        return;
      this.target = el;
      this.targetShadow?.update(el);
      if (this.moveable) {
        this.moveable.zoom = 2;
        this.moveable.updateRect();
      } else {
        this.moveable = new Moveable(this.container, {
          target: this.targetShadow?.el,
          origin: false,
          rootContainer: this.getRootContainer(),
          zoom: 2
        });
      }
    }
    /**
     * 清空高亮
     */
    clearHighlight() {
      if (!this.moveable || !this.target)
        return;
      this.moveable.zoom = 0;
      this.moveable.updateRect();
      this.target = void 0;
    }
    /**
     * 销毁实例
     */
    destroy() {
      this.moveable?.destroy();
      this.targetShadow?.destroy();
      this.moveable = void 0;
      this.targetShadow = void 0;
    }
  }

  class StageMultiDragResize extends MoveableOptionsManager {
    /** 画布容器 */
    container;
    /** 多选:目标节点组 */
    targetList = [];
    /** Moveable多选拖拽类实例 */
    moveableForMulti;
    dragStatus = StageDragStatus.END;
    dragResizeHelper;
    getRenderDocument;
    delayedMarkContainer;
    markContainerEnd;
    constructor(config) {
      const moveableOptionsManagerConfig = {
        container: config.container,
        moveableOptions: config.moveableOptions,
        getRootContainer: config.getRootContainer
      };
      super(moveableOptionsManagerConfig);
      this.delayedMarkContainer = config.delayedMarkContainer;
      this.markContainerEnd = config.markContainerEnd;
      this.container = config.container;
      this.getRenderDocument = config.getRenderDocument;
      this.dragResizeHelper = config.dragResizeHelper;
      this.on("update-moveable", () => {
        if (this.moveableForMulti) {
          this.updateMoveable();
        }
      });
    }
    /**
     * 多选
     * @param els
     */
    multiSelect(els) {
      if (els.length === 0) {
        return;
      }
      this.mode = getMode(els[0]);
      this.targetList = els;
      this.dragResizeHelper.updateGroup(els);
      const elementGuidelines = Array.prototype.slice.call(this.targetList[0].parentElement?.children) || [];
      this.setElementGuidelines(this.targetList, elementGuidelines);
      this.moveableForMulti?.destroy();
      this.dragResizeHelper.clear();
      this.moveableForMulti = new Moveable(
        this.container,
        this.getOptions(true, {
          target: this.dragResizeHelper.getShadowEls()
        })
      );
      let timeout;
      this.moveableForMulti.on("resizeGroupStart", (e) => {
        this.dragResizeHelper.onResizeGroupStart(e);
        this.dragStatus = StageDragStatus.START;
      }).on("resizeGroup", (e) => {
        this.dragResizeHelper.onResizeGroup(e);
        this.dragStatus = StageDragStatus.ING;
      }).on("resizeGroupEnd", () => {
        this.update(true);
        this.dragStatus = StageDragStatus.END;
      }).on("dragGroupStart", (e) => {
        this.dragResizeHelper.onDragGroupStart(e);
        this.dragStatus = StageDragStatus.START;
      }).on("dragGroup", (e) => {
        if (timeout) {
          globalThis.clearTimeout(timeout);
          timeout = void 0;
        }
        timeout = this.delayedMarkContainer(e.inputEvent, this.targetList);
        this.dragResizeHelper.onDragGroup(e);
        this.dragStatus = StageDragStatus.ING;
      }).on("dragGroupEnd", () => {
        const parentEl = this.markContainerEnd();
        this.update(false, parentEl);
        this.dragStatus = StageDragStatus.END;
      }).on("clickGroup", (e) => {
        const { inputTarget, targets } = e;
        if (targets.length > 1 && targets.includes(inputTarget)) {
          this.emit("change-to-select", inputTarget.id.replace(DRAG_EL_ID_PREFIX, ""));
        }
      });
    }
    canSelect(el, selectedEl) {
      const currentTargetMode = getMode(el);
      let selectedElMode = "";
      if (currentTargetMode === Mode.SORTABLE) {
        return false;
      }
      if (this.targetList.length === 0 && selectedEl) {
        selectedElMode = getMode(selectedEl);
      } else if (this.targetList.length > 0) {
        selectedElMode = getMode(this.targetList[0]);
      }
      if (currentTargetMode !== selectedElMode) {
        return false;
      }
      return true;
    }
    updateMoveable(eleList = this.targetList) {
      if (!this.moveableForMulti)
        return;
      if (!eleList)
        throw new Error("未选中任何节点");
      this.targetList = eleList;
      this.dragResizeHelper.setTargetList(eleList);
      const options = this.getOptions(true, {
        target: this.dragResizeHelper.getShadowEls()
      });
      Object.entries(options).forEach(([key, value]) => {
        this.moveableForMulti[key] = value;
      });
      this.moveableForMulti.updateRect();
    }
    /**
     * 清除多选状态
     */
    clearSelectStatus() {
      if (!this.moveableForMulti)
        return;
      this.dragResizeHelper.clearMultiSelectStatus();
      this.moveableForMulti.target = null;
      this.moveableForMulti.updateTarget();
      this.targetList = [];
    }
    /**
     * 销毁实例
     */
    destroy() {
      this.moveableForMulti?.destroy();
      this.dragResizeHelper.destroy();
    }
    /**
     * 拖拽完成后将更新的位置信息暴露给上层业务方，业务方可以接收事件进行保存
     * @param isResize 是否进行大小缩放
     */
    update(isResize = false, parentEl = null) {
      if (this.targetList.length === 0)
        return;
      const doc = this.getRenderDocument();
      if (!doc)
        return;
      const data = this.targetList.map((targetItem) => {
        const rect = this.dragResizeHelper.getUpdatedElRect(targetItem, parentEl, doc);
        return {
          el: targetItem,
          style: isResize ? rect : { left: rect.left, top: rect.top }
        };
      });
      this.emit("update", { data, parentEl });
    }
  }

  const throttleTime = 100;
  const defaultContainerHighlightDuration = 800;
  class ActionManager extends EventEmitter {
    dr;
    multiDr;
    highlightLayer;
    /** 单选、多选、高亮的容器（蒙层的content） */
    container;
    /** 当前选中的节点 */
    selectedEl;
    /** 多选选中的节点组 */
    selectedElList = [];
    /** 当前高亮的节点 */
    highlightedEl;
    /** 当前是否处于多选状态 */
    isMultiSelectStatus = false;
    /** 当拖拽组件到容器上方进入可加入容器状态时，给容器添加的一个class名称 */
    containerHighlightClassName;
    /** 当拖拽组件到容器上方时，需要悬停多久才能将组件加入容器 */
    containerHighlightDuration;
    /** 将组件加入容器的操作方式 */
    containerHighlightType;
    isAltKeydown = false;
    getTargetElement;
    getElementsFromPoint;
    canSelect;
    isContainer;
    getRenderDocument;
    mouseMoveHandler = lodashEs.throttle(async (event) => {
      const el = await this.getElementFromPoint(event);
      if (!el) {
        this.clearHighlight();
        return;
      }
      this.emit("mousemove", event);
      this.highlight(el);
    }, throttleTime);
    constructor(config) {
      super();
      this.container = config.container;
      this.containerHighlightClassName = config.containerHighlightClassName || CONTAINER_HIGHLIGHT_CLASS_NAME;
      this.containerHighlightDuration = config.containerHighlightDuration || defaultContainerHighlightDuration;
      this.containerHighlightType = config.containerHighlightType;
      this.getTargetElement = config.getTargetElement;
      this.getElementsFromPoint = config.getElementsFromPoint;
      this.canSelect = config.canSelect || ((el) => !!el.id);
      this.getRenderDocument = config.getRenderDocument;
      this.isContainer = config.isContainer;
      const createDrHelper = () => new DragResizeHelper({
        container: config.container,
        updateDragEl: config.updateDragEl
      });
      this.dr = new StageDragResize({
        container: config.container,
        disabledDragStart: config.disabledDragStart,
        moveableOptions: this.changeCallback(config.moveableOptions, false),
        dragResizeHelper: createDrHelper(),
        getRootContainer: config.getRootContainer,
        getRenderDocument: config.getRenderDocument,
        markContainerEnd: this.markContainerEnd.bind(this),
        delayedMarkContainer: this.delayedMarkContainer.bind(this)
      });
      this.multiDr = new StageMultiDragResize({
        container: config.container,
        moveableOptions: this.changeCallback(config.moveableOptions, true),
        dragResizeHelper: createDrHelper(),
        getRootContainer: config.getRootContainer,
        getRenderDocument: config.getRenderDocument,
        markContainerEnd: this.markContainerEnd.bind(this),
        delayedMarkContainer: this.delayedMarkContainer.bind(this)
      });
      this.highlightLayer = new StageHighlight({
        container: config.container,
        updateDragEl: config.updateDragEl,
        getRootContainer: config.getRootContainer
      });
      this.initMouseEvent();
      this.initKeyEvent();
      this.initActionEvent();
    }
    /**
     * 设置水平/垂直参考线
     * @param type 参考线类型
     * @param guidelines 参考线坐标数组
     */
    setGuidelines(type, guidelines) {
      this.dr.setGuidelines(type, guidelines);
      this.multiDr.setGuidelines(type, guidelines);
    }
    /**
     * 清空所有参考线
     */
    clearGuides() {
      this.dr.clearGuides();
      this.multiDr.clearGuides();
    }
    /**
     * 更新moveable，外部主要调用场景是元素配置变更、页面大小变更
     * @param el 变更的元素
     */
    updateMoveable(el) {
      this.dr.updateMoveable(el);
      this.multiDr.updateMoveable();
    }
    /**
     * 判断是否单选选中的元素
     */
    isSelectedEl(el) {
      return el.id === this.selectedEl?.id;
    }
    setSelectedEl(el) {
      this.selectedEl = el;
    }
    getSelectedEl() {
      return this.selectedEl;
    }
    getSelectedElList() {
      return this.selectedElList;
    }
    getMoveableOption(key) {
      if (this.dr.getTarget()) {
        return this.dr.getOption(key);
      }
      if (this.multiDr.targetList.length) {
        return this.multiDr.getOption(key);
      }
    }
    /**
     * 获取鼠标下方第一个可选中元素，如果元素层叠，返回到是最上层元素
     * @param event 鼠标事件
     * @returns 鼠标下方第一个可选中元素
     */
    async getElementFromPoint(event) {
      const els = this.getElementsFromPoint(event);
      this.emit("get-elements-from-point", els);
      let stopped = false;
      const stop = () => stopped = true;
      for (const el of els) {
        if (!el.id.startsWith(GHOST_EL_ID_PREFIX) && await this.isElCanSelect(el, event, stop)) {
          if (stopped)
            break;
          return el;
        }
      }
    }
    /**
     * 判断一个元素能否在当前场景被选中
     * @param el 被判断的元素
     * @param event 鼠标事件
     * @param stop 通过该元素如果得知剩下的元素都不可被选中，通知调用方终止对剩下元素的判断
     * @returns 能否选中
     */
    async isElCanSelect(el, event, stop) {
      const canSelectByProp = await this.canSelect(el, event, stop);
      if (!canSelectByProp)
        return false;
      if (this.isMultiSelectStatus) {
        return this.canMultiSelect(el, stop);
      }
      return true;
    }
    /**
     * 判断一个元素是否可以被多选，如果当前元素是page，则调stop函数告诉调用方不必继续判断其它元素了
     */
    canMultiSelect(el, stop) {
      if (el.className.includes(PAGE_CLASS)) {
        stop();
        return false;
      }
      const selectedEl = this.getSelectedEl();
      if (selectedEl?.className.includes(PAGE_CLASS)) {
        return true;
      }
      return this.multiDr.canSelect(el, selectedEl);
    }
    select(el, event) {
      this.selectedEl = el;
      this.clearSelectStatus(SelectStatus.MULTI_SELECT);
      this.dr.select(el, event);
    }
    multiSelect(idOrElList) {
      this.selectedElList = idOrElList.map((idOrEl) => this.getTargetElement(idOrEl));
      this.clearSelectStatus(SelectStatus.SELECT);
      this.multiDr.multiSelect(this.selectedElList);
    }
    getHighlightEl() {
      return this.highlightedEl;
    }
    setHighlightEl(el) {
      this.highlightedEl = el;
    }
    highlight(idOrEl) {
      let el;
      try {
        el = this.getTargetElement(idOrEl);
      } catch (error) {
        this.clearHighlight();
        return;
      }
      if (el === this.getSelectedEl() || this.multiDr.dragStatus === StageDragStatus.ING) {
        this.clearHighlight();
        return;
      }
      if (el === this.highlightedEl || !el)
        return;
      this.highlightLayer.highlight(el);
      this.highlightedEl = el;
      this.emit("highlight", el);
    }
    clearHighlight() {
      this.setHighlightEl(void 0);
      this.highlightLayer.clearHighlight();
    }
    /**
     * 用于在切换选择模式时清除上一次的状态
     * @param selectType 需要清理的选择模式
     */
    clearSelectStatus(selectType) {
      if (selectType === SelectStatus.MULTI_SELECT) {
        this.multiDr.clearSelectStatus();
        this.selectedElList = [];
      } else {
        this.dr.clearSelectStatus();
      }
    }
    /**
     * 找到鼠标下方的容器，通过添加className对容器进行标记
     * @param event 鼠标事件
     * @param excludeElList 计算鼠标点所在容器时要排除的元素列表
     */
    async addContainerHighlightClassName(event, excludeElList) {
      const doc = this.getRenderDocument();
      if (!doc)
        return;
      const els = this.getElementsFromPoint(event);
      for (const el of els) {
        if (!el.id.startsWith(GHOST_EL_ID_PREFIX) && await this.isContainer(el) && !excludeElList.includes(el)) {
          utils.addClassName(el, doc, this.containerHighlightClassName);
          break;
        }
      }
    }
    /**
     * 鼠标拖拽着元素，在容器上方悬停，延迟一段时间后，对容器进行标记，如果悬停时间够长将标记成功，悬停时间短，调用方通过返回的timeoutId取消标记
     * 标记的作用：1、高亮容器，给用户一个加入容器的交互感知；2、释放鼠标后，通过标记的标志找到要加入的容器
     * @param event 鼠标事件
     * @param excludeElList 计算鼠标所在容器时要排除的元素列表
     * @returns timeoutId，调用方在鼠标移走时要取消该timeout，阻止标记
     */
    delayedMarkContainer(event, excludeElList = []) {
      if (this.canAddToContainer()) {
        return globalThis.setTimeout(() => {
          this.addContainerHighlightClassName(event, excludeElList);
        }, this.containerHighlightDuration);
      }
      return void 0;
    }
    getDragStatus() {
      return this.dr.getDragStatus();
    }
    destroy() {
      this.container.removeEventListener("mousedown", this.mouseDownHandler);
      this.container.removeEventListener("mousemove", this.mouseMoveHandler);
      this.container.removeEventListener("mouseleave", this.mouseLeaveHandler);
      this.container.removeEventListener("wheel", this.mouseWheelHandler);
      this.dr.destroy();
      this.multiDr.destroy();
      this.highlightLayer.destroy();
    }
    changeCallback(options, isMulti) {
      if (typeof options === "function") {
        return () => {
          if (typeof options === "function") {
            const cfg = {
              targetEl: this.selectedEl,
              targetElId: this.selectedEl?.id,
              targetEls: this.selectedElList,
              targetElIds: this.selectedElList?.map((item) => item.id),
              isMulti
            };
            return options(cfg);
          }
          return options;
        };
      }
      return options;
    }
    /**
     * 在执行多选逻辑前，先准备好多选选中元素
     * @param el 新选中的元素
     * @returns 多选选中的元素列表
     */
    async beforeMultiSelect(event) {
      const el = await this.getElementFromPoint(event);
      if (!el)
        return;
      if (this.selectedEl && !this.selectedEl.className.includes(PAGE_CLASS)) {
        this.selectedElList.push(this.selectedEl);
        this.selectedEl = void 0;
      }
      const existIndex = this.selectedElList.findIndex((selectedDom) => selectedDom.id === el.id);
      if (existIndex !== -1) {
        this.selectedElList.splice(existIndex, 1);
      } else {
        this.selectedElList.push(el);
      }
    }
    /**
     * 当前状态下能否将组件加入容器，默认是鼠标悬停一段时间加入，alt模式则是按住alt+鼠标悬停一段时间加入
     */
    canAddToContainer() {
      return this.containerHighlightType === ContainerHighlightType.DEFAULT || this.containerHighlightType === ContainerHighlightType.ALT && this.isAltKeydown;
    }
    /**
     * 结束对container的标记状态
     * @returns 标记的容器元素，没有标记的容器时返回null
     */
    markContainerEnd() {
      const doc = this.getRenderDocument();
      if (doc && this.canAddToContainer()) {
        return utils.removeClassNameByClassName(doc, this.containerHighlightClassName);
      }
      return null;
    }
    initMouseEvent() {
      this.container.addEventListener("mousedown", this.mouseDownHandler);
      this.container.addEventListener("mousemove", this.mouseMoveHandler);
      this.container.addEventListener("mouseleave", this.mouseLeaveHandler);
      this.container.addEventListener("wheel", this.mouseWheelHandler);
    }
    /**
     * 初始化键盘事件监听
     */
    initKeyEvent() {
      const { isMac } = new core.Env();
      const ctrl = isMac ? "meta" : "ctrl";
      KeyController.global.keydown(ctrl, (e) => {
        e.inputEvent.preventDefault();
        this.isMultiSelectStatus = true;
      });
      KeyController.global.on("blur", () => {
        this.isMultiSelectStatus = false;
      });
      KeyController.global.keyup(ctrl, (e) => {
        e.inputEvent.preventDefault();
        this.isMultiSelectStatus = false;
      });
      KeyController.global.keydown("alt", (e) => {
        e.inputEvent.preventDefault();
        this.isAltKeydown = true;
      });
      KeyController.global.keyup("alt", (e) => {
        e.inputEvent.preventDefault();
        this.markContainerEnd();
        this.isAltKeydown = false;
      });
    }
    /**
     * 处理单选、多选抛出来的事件
     */
    initActionEvent() {
      this.dr.on("update", (data) => {
        setTimeout(() => this.emit("update", data));
      }).on("sort", (data) => {
        setTimeout(() => this.emit("sort", data));
      }).on("select-parent", () => {
        this.emit("select-parent");
      }).on("remove", () => {
        const drTarget = this.dr.getTarget();
        if (!drTarget)
          return;
        const data = {
          data: [{ el: drTarget }]
        };
        this.emit("remove", data);
      }).on("drag-start", (e) => {
        this.emit("drag-start", e);
      });
      this.multiDr.on("update", (data) => {
        this.emit("multi-update", data);
      }).on("change-to-select", async (id) => {
        if (this.isMultiSelectStatus)
          return false;
        const el = this.getTargetElement(id);
        this.emit("change-to-select", el);
      });
    }
    /**
     * 在down事件中集中cpu处理画布中选中操作渲染，在up事件中再通知外面的编辑器更新
     */
    mouseDownHandler = async (event) => {
      this.clearHighlight();
      event.stopImmediatePropagation();
      event.stopPropagation();
      if (this.isStopTriggerSelect(event))
        return;
      this.container.removeEventListener("mousemove", this.mouseMoveHandler);
      if (this.isMultiSelectStatus) {
        await this.beforeMultiSelect(event);
        if (this.selectedElList.length > 0) {
          this.emit("before-multi-select", this.selectedElList);
        }
      } else {
        const el = await this.getElementFromPoint(event);
        if (!el)
          return;
        this.emit("before-select", el, event);
      }
      utils.getDocument().addEventListener("mouseup", this.mouseUpHandler);
    };
    isStopTriggerSelect(event) {
      if (event.button !== MouseButton.LEFT && event.button !== MouseButton.RIGHT)
        return true;
      if (!event.target)
        return true;
      const targetClassList = event.target.classList;
      if (!this.isMultiSelectStatus && targetClassList.contains("moveable-area")) {
        return true;
      }
      if (targetClassList.contains("moveable-control") || isMoveableButton(event.target)) {
        return true;
      }
      return false;
    }
    /**
     * 在up事件中负责对外通知选中事件，通知画布之外的编辑器更新
     */
    mouseUpHandler = () => {
      utils.getDocument().removeEventListener("mouseup", this.mouseUpHandler);
      this.container.addEventListener("mousemove", this.mouseMoveHandler);
      if (this.isMultiSelectStatus) {
        this.emit("multi-select", this.selectedElList);
      } else {
        this.emit("select", this.selectedEl);
      }
    };
    mouseLeaveHandler = (event) => {
      setTimeout(() => this.clearHighlight(), throttleTime);
      this.emit("mouseleave", event);
    };
    mouseWheelHandler = () => {
      this.clearHighlight();
    };
  }

  class Rule extends EventEmitter {
    hGuides;
    vGuides;
    horizontalGuidelines = [];
    verticalGuidelines = [];
    container;
    containerResizeObserver;
    isShowGuides = true;
    constructor(container) {
      super();
      this.container = container;
      this.hGuides = this.createGuides(GuidesType.HORIZONTAL, this.horizontalGuidelines);
      this.vGuides = this.createGuides(GuidesType.VERTICAL, this.verticalGuidelines);
      this.hGuides.on("changeGuides", this.hGuidesChangeGuidesHandler);
      this.vGuides.on("changeGuides", this.vGuidesChangeGuidesHandler);
      this.containerResizeObserver = new ResizeObserver(() => {
        this.vGuides.resize();
        this.hGuides.resize();
      });
      this.containerResizeObserver.observe(this.container);
    }
    /**
     * 是否显示辅助线
     * @param isShowGuides 是否显示
     */
    showGuides(isShowGuides = true) {
      this.isShowGuides = isShowGuides;
      this.hGuides.setState({
        showGuides: isShowGuides
      });
      this.vGuides.setState({
        showGuides: isShowGuides
      });
    }
    setGuides([hLines, vLines]) {
      this.horizontalGuidelines = hLines;
      this.verticalGuidelines = vLines;
      this.hGuides.setState({
        defaultGuides: hLines
      });
      this.vGuides.setState({
        defaultGuides: vLines
      });
      this.emit("change-guides", {
        type: GuidesType.HORIZONTAL,
        guides: hLines
      });
      this.emit("change-guides", {
        type: GuidesType.VERTICAL,
        guides: vLines
      });
    }
    /**
     * 清空所有参考线
     */
    clearGuides() {
      this.setGuides([[], []]);
    }
    /**
     * 是否显示标尺
     * @param show 是否显示
     */
    showRule(show = true) {
      if (show) {
        this.hGuides.destroy();
        this.hGuides = this.createGuides(GuidesType.HORIZONTAL, this.horizontalGuidelines);
        this.vGuides.destroy();
        this.vGuides = this.createGuides(GuidesType.VERTICAL, this.verticalGuidelines);
      } else {
        this.hGuides.setState({
          rulerStyle: {
            visibility: "hidden"
          }
        });
        this.vGuides.setState({
          rulerStyle: {
            visibility: "hidden"
          }
        });
      }
    }
    scrollRule(scrollTop) {
      this.hGuides.scrollGuides(scrollTop);
      this.hGuides.scroll(0);
      this.vGuides.scrollGuides(0);
      this.vGuides.scroll(scrollTop);
    }
    destroy() {
      this.hGuides.off("changeGuides", this.hGuidesChangeGuidesHandler);
      this.vGuides.off("changeGuides", this.vGuidesChangeGuidesHandler);
      this.containerResizeObserver.disconnect();
      this.removeAllListeners();
    }
    getGuidesStyle = (type) => ({
      position: "fixed",
      zIndex: 1,
      left: type === GuidesType.HORIZONTAL ? 0 : "-30px",
      top: type === GuidesType.HORIZONTAL ? "-30px" : 0,
      width: type === GuidesType.HORIZONTAL ? "100%" : "30px",
      height: type === GuidesType.HORIZONTAL ? "30px" : "100%"
    });
    createGuides = (type, defaultGuides = []) => new Guides(this.container, {
      type,
      defaultGuides,
      displayDragPos: true,
      backgroundColor: "#fff",
      lineColor: "#000",
      textColor: "#000",
      style: this.getGuidesStyle(type),
      showGuides: this.isShowGuides
    });
    hGuidesChangeGuidesHandler = (e) => {
      this.horizontalGuidelines = e.guides;
      this.emit("change-guides", {
        type: GuidesType.HORIZONTAL,
        guides: this.horizontalGuidelines
      });
    };
    vGuidesChangeGuidesHandler = (e) => {
      this.verticalGuidelines = e.guides;
      this.emit("change-guides", {
        type: GuidesType.VERTICAL,
        guides: this.verticalGuidelines
      });
    };
  }

  const wrapperClassName = "editor-mask-wrapper";
  const hideScrollbar = () => {
    utils.injectStyle(utils.getDocument(), `.${wrapperClassName}::-webkit-scrollbar { width: 0 !important; display: none }`);
  };
  const createContent = () => utils.createDiv({
    className: "editor-mask",
    cssText: `
    position: absolute;
    top: 0;
    left: 0;
    transform: translate3d(0, 0, 0);
  `
  });
  const createWrapper = () => {
    const el = utils.createDiv({
      className: wrapperClassName,
      cssText: `
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      z-index: ${ZIndex.MASK};
    `
    });
    hideScrollbar();
    return el;
  };
  class StageMask extends Rule {
    content = createContent();
    wrapper;
    page = null;
    scrollTop = 0;
    scrollLeft = 0;
    width = 0;
    height = 0;
    wrapperHeight = 0;
    wrapperWidth = 0;
    maxScrollTop = 0;
    maxScrollLeft = 0;
    mode = Mode.ABSOLUTE;
    pageScrollParent = null;
    intersectionObserver = null;
    wrapperResizeObserver = null;
    constructor() {
      const wrapper = createWrapper();
      super(wrapper);
      this.wrapper = wrapper;
      this.content.addEventListener("wheel", this.mouseWheelHandler);
      this.wrapper.appendChild(this.content);
    }
    setMode(mode) {
      this.mode = mode;
      this.scroll();
      this.content.dataset.mode = mode;
      if (mode === Mode.FIXED) {
        this.content.style.width = `${this.wrapperWidth}px`;
        this.content.style.height = `${this.wrapperHeight}px`;
      } else {
        this.content.style.width = `${this.width}px`;
        this.content.style.height = `${this.height}px`;
      }
    }
    /**
     * 初始化视窗和蒙层监听，监听元素是否在视窗区域、监听mask蒙层所在的wrapper大小变化
     * @description 初始化视窗和蒙层监听
     * @param page 页面Dom节点
     */
    observe(page) {
      if (!page)
        return;
      this.page = page;
      this.initObserverIntersection();
      this.initObserverWrapper();
    }
    /**
     * 处理页面大小变更，同步页面和mask大小
     * @param entries ResizeObserverEntry，获取页面最新大小
     */
    pageResize(entries) {
      const [entry] = entries;
      const { clientHeight, clientWidth } = entry.target;
      this.setHeight(clientHeight);
      this.setWidth(clientWidth);
      this.scroll();
    }
    /**
     * 监听一个组件是否在画布可视区域内
     * @param el 被选中的组件，可能是左侧目录树中选中的
     */
    observerIntersection(el) {
      this.intersectionObserver?.observe(el);
    }
    /**
     * 挂载Dom节点
     * @param el 将蒙层挂载到该Dom节点上
     */
    mount(el) {
      if (!this.content)
        throw new Error("content 不存在");
      el.appendChild(this.wrapper);
    }
    setLayout(el) {
      this.setMode(isFixedParent(el) ? Mode.FIXED : Mode.ABSOLUTE);
    }
    scrollIntoView(el) {
      el.scrollIntoView();
      if (!this.pageScrollParent)
        return;
      this.scrollLeft = this.pageScrollParent.scrollLeft;
      this.scrollTop = this.pageScrollParent.scrollTop;
      this.scroll();
    }
    /**
     * 销毁实例
     */
    destroy() {
      this.content?.remove();
      this.page = null;
      this.pageScrollParent = null;
      this.wrapperResizeObserver?.disconnect();
      super.destroy();
    }
    /**
     * 监听选中元素是否在画布可视区域内，如果目标元素不在可视区域内，通过滚动使该元素出现在可视区域
     */
    initObserverIntersection() {
      this.pageScrollParent = getScrollParent(this.page) || null;
      this.intersectionObserver?.disconnect();
      if (typeof IntersectionObserver !== "undefined") {
        this.intersectionObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              const { target, intersectionRatio } = entry;
              if (intersectionRatio <= 0) {
                this.scrollIntoView(target);
              }
              this.intersectionObserver?.unobserve(target);
            });
          },
          {
            root: this.pageScrollParent,
            rootMargin: "0px",
            threshold: 1
          }
        );
      }
    }
    /**
     * 监听mask的容器大小变化
     */
    initObserverWrapper() {
      this.wrapperResizeObserver?.disconnect();
      if (typeof ResizeObserver !== "undefined") {
        this.wrapperResizeObserver = new ResizeObserver((entries) => {
          const [entry] = entries;
          const { clientHeight, clientWidth } = entry.target;
          this.wrapperHeight = clientHeight;
          this.wrapperWidth = clientWidth;
          this.setMaxScrollLeft();
          this.setMaxScrollTop();
        });
        this.wrapperResizeObserver.observe(this.wrapper);
      }
    }
    scroll() {
      this.fixScrollValue();
      let { scrollLeft, scrollTop } = this;
      if (this.pageScrollParent) {
        this.pageScrollParent.scrollTo({
          top: scrollTop,
          left: scrollLeft
        });
      }
      if (this.mode === Mode.FIXED) {
        scrollLeft = 0;
        scrollTop = 0;
      }
      this.scrollRule(scrollTop);
      this.scrollTo(scrollLeft, scrollTop);
    }
    scrollTo(scrollLeft, scrollTop) {
      this.content.style.transform = `translate3d(${-scrollLeft}px, ${-scrollTop}px, 0)`;
      const event = new CustomEvent("customScroll", {
        detail: {
          scrollLeft: this.scrollLeft,
          scrollTop: this.scrollTop
        }
      });
      this.content.dispatchEvent(event);
    }
    /**
     * 设置蒙层高度
     * @param height 高度
     */
    setHeight(height) {
      this.height = height;
      this.setMaxScrollTop();
      this.content.style.height = `${height}px`;
    }
    /**
     * 设置蒙层宽度
     * @param width 宽度
     */
    setWidth(width) {
      this.width = width;
      this.setMaxScrollLeft();
      this.content.style.width = `${width}px`;
    }
    /**
     * 计算并设置最大滚动宽度
     */
    setMaxScrollLeft() {
      this.maxScrollLeft = Math.max(this.width - this.wrapperWidth, 0);
    }
    /**
     * 计算并设置最大滚动高度
     */
    setMaxScrollTop() {
      this.maxScrollTop = Math.max(this.height - this.wrapperHeight, 0);
    }
    /**
     * 修复滚动距离
     * 由于滚动容器变化等因素，会导致当前滚动的距离不正确
     */
    fixScrollValue() {
      if (this.scrollTop < 0)
        this.scrollTop = 0;
      if (this.scrollLeft < 0)
        this.scrollLeft = 0;
      if (this.maxScrollTop < this.scrollTop)
        this.scrollTop = this.maxScrollTop;
      if (this.maxScrollLeft < this.scrollLeft)
        this.scrollLeft = this.maxScrollLeft;
    }
    mouseWheelHandler = (event) => {
      if (!this.page)
        throw new Error("page 未初始化");
      const { deltaY, deltaX } = event;
      if (this.page.clientHeight < this.wrapperHeight && deltaY)
        return;
      if (this.page.clientWidth < this.wrapperWidth && deltaX)
        return;
      if (this.maxScrollTop > 0) {
        this.scrollTop = this.scrollTop + deltaY;
      }
      if (this.maxScrollLeft > 0) {
        this.scrollLeft = this.scrollLeft + deltaX;
      }
      this.scroll();
      this.emit("scroll", event);
    };
  }

  const style = ".tmagic-stage-container-highlight::after {\n  content: '';\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  background-color: #000;\n  opacity: .1;\n  pointer-events: none;\n}\n\n.magic-ui-container.magic-layout-relative {\n  min-height: 50px;\n}\n";

  class StageRender extends EventEmitter.EventEmitter {
    /** 组件的js、css执行的环境，直接渲染为当前window，iframe渲染则为iframe.contentWindow */
    contentWindow = null;
    runtime = null;
    iframe;
    runtimeUrl;
    zoom = DEFAULT_ZOOM;
    customizedRender;
    constructor({ runtimeUrl, zoom, customizedRender }) {
      super();
      this.runtimeUrl = runtimeUrl || "";
      this.customizedRender = customizedRender;
      this.setZoom(zoom);
      this.iframe = globalThis.document.createElement("iframe");
      this.iframe.src = utils.isSameDomain(this.runtimeUrl) ? this.runtimeUrl : "";
      this.iframe.style.cssText = `
      border: 0;
      width: 100%;
      height: 100%;
    `;
      this.iframe.addEventListener("load", this.loadHandler);
    }
    getMagicApi = () => ({
      onPageElUpdate: (el) => this.emit("page-el-update", el),
      onRuntimeReady: (runtime) => {
        this.runtime = runtime;
        globalThis.runtime = runtime;
        this.emit("runtime-ready", runtime);
      }
    });
    async add(data) {
      const runtime = await this.getRuntime();
      return runtime?.add?.(data);
    }
    async remove(data) {
      const runtime = await this.getRuntime();
      return runtime?.remove?.(data);
    }
    async update(data) {
      const runtime = await this.getRuntime();
      runtime?.update?.(data);
    }
    async select(els) {
      const runtime = await this.getRuntime();
      for (const el of els) {
        await runtime?.select?.(el.id);
        if (runtime?.beforeSelect) {
          await runtime.beforeSelect(el);
        }
        this.flagSelectedEl(el);
      }
    }
    setZoom(zoom = DEFAULT_ZOOM) {
      this.zoom = zoom;
    }
    /**
     * 挂载Dom节点
     * @param el 将页面挂载到该Dom节点上
     */
    async mount(el) {
      if (!this.iframe) {
        throw Error("mount 失败");
      }
      if (!utils.isSameDomain(this.runtimeUrl) && this.runtimeUrl) {
        let html = await fetch(this.runtimeUrl).then((res) => res.text());
        const base = `${location.protocol}//${utils.getHost(this.runtimeUrl)}`;
        html = html.replace("<head>", `<head>
<base href="${base}">`);
        this.iframe.srcdoc = html;
      }
      el.appendChild(this.iframe);
      this.postTmagicRuntimeReady();
    }
    getRuntime = () => {
      if (this.runtime)
        return Promise.resolve(this.runtime);
      return new Promise((resolve) => {
        const listener = (runtime) => {
          this.off("runtime-ready", listener);
          resolve(runtime);
        };
        this.on("runtime-ready", listener);
      });
    };
    getDocument() {
      return this.contentWindow?.document;
    }
    /**
     * 通过坐标获得坐标下所有HTML元素数组
     * @param point 坐标
     * @returns 坐标下方所有HTML元素数组，会包含父元素直至html，元素层叠时返回顺序是从上到下
     */
    getElementsFromPoint(point) {
      let x = point.clientX;
      let y = point.clientY;
      if (this.iframe) {
        const rect = this.iframe.getClientRects()[0];
        if (rect) {
          x = x - rect.left;
          y = y - rect.top;
        }
      }
      return this.getDocument()?.elementsFromPoint(x / this.zoom, y / this.zoom);
    }
    getTargetElement(idOrEl) {
      if (typeof idOrEl === "string" || typeof idOrEl === "number") {
        const el = this.getDocument()?.getElementById(`${idOrEl}`);
        if (!el)
          throw new Error(`不存在ID为${idOrEl}的元素`);
        return el;
      }
      return idOrEl;
    }
    /**
     * 销毁实例
     */
    destroy() {
      this.iframe?.removeEventListener("load", this.loadHandler);
      this.contentWindow = null;
      this.iframe?.remove();
      this.iframe = void 0;
      this.removeAllListeners();
    }
    /**
     * 在runtime中对被选中的元素进行标记，部分组件有对选中态进行特殊显示的需求
     * @param el 被选中的元素
     */
    flagSelectedEl(el) {
      const doc = this.getDocument();
      if (doc) {
        removeSelectedClassName(doc);
        addSelectedClassName(el, doc);
      }
    }
    loadHandler = async () => {
      if (!this.contentWindow?.magic) {
        this.postTmagicRuntimeReady();
      }
      if (!this.contentWindow)
        return;
      if (this.customizedRender) {
        const el = await this.customizedRender();
        if (el) {
          this.contentWindow.document?.body?.appendChild(el);
        }
      }
      this.emit("onload");
      utils.injectStyle(this.contentWindow.document, style);
    };
    postTmagicRuntimeReady() {
      this.contentWindow = this.iframe?.contentWindow;
      this.contentWindow.magic = this.getMagicApi();
      this.contentWindow.postMessage(
        {
          tmagicRuntimeReady: true
        },
        "*"
      );
    }
  }

  class StageCore extends EventEmitter.EventEmitter {
    container;
    renderer;
    mask;
    actionManager;
    pageResizeObserver = null;
    autoScrollIntoView;
    customizedRender;
    constructor(config) {
      super();
      this.autoScrollIntoView = config.autoScrollIntoView;
      this.customizedRender = config.render;
      this.renderer = new StageRender({
        runtimeUrl: config.runtimeUrl,
        zoom: config.zoom,
        customizedRender: async () => {
          if (this?.customizedRender) {
            return await this.customizedRender(this);
          }
          return null;
        }
      });
      this.mask = new StageMask();
      this.actionManager = new ActionManager(this.getActionManagerConfig(config));
      this.initRenderEvent();
      this.initActionEvent();
      this.initMaskEvent();
    }
    /**
     * 单选选中元素
     * @param idOrEl 选中的id或者元素
     */
    async select(idOrEl, event) {
      const el = this.renderer.getTargetElement(idOrEl);
      if (el === this.actionManager.getSelectedEl())
        return;
      await this.renderer.select([el]);
      this.mask.setLayout(el);
      this.actionManager.select(el, event);
      if (this.autoScrollIntoView || el.dataset.autoScrollIntoView) {
        this.mask.observerIntersection(el);
      }
    }
    /**
     * 多选选中多个元素
     * @param idOrElList 选中元素的id或元素列表
     */
    async multiSelect(idOrElList) {
      const els = idOrElList.map((idOrEl) => this.renderer.getTargetElement(idOrEl));
      if (els.length === 0)
        return;
      const lastEl = els[els.length - 1];
      const isReduceSelect = els.length < this.actionManager.getSelectedElList().length;
      await this.renderer.select(els);
      this.mask.setLayout(lastEl);
      this.actionManager.multiSelect(idOrElList);
      if ((this.autoScrollIntoView || lastEl.dataset.autoScrollIntoView) && !isReduceSelect) {
        this.mask.observerIntersection(lastEl);
      }
    }
    /**
     * 高亮选中元素
     * @param el 要高亮的元素
     */
    highlight(idOrEl) {
      this.actionManager.highlight(idOrEl);
    }
    clearHighlight() {
      this.actionManager.clearHighlight();
    }
    /**
     * 更新组件
     * @param data 更新组件的数据
     */
    async update(data) {
      const { config } = data;
      await this.renderer.update(data);
      setTimeout(() => {
        const el = this.renderer.getTargetElement(`${config.id}`);
        if (el && this.actionManager.isSelectedEl(el)) {
          this.mask.setLayout(el);
          this.actionManager.setSelectedEl(el);
          this.actionManager.updateMoveable(el);
        }
      });
    }
    /**
     * 往画布增加一个组件
     * @param data 组件信息数据
     */
    async add(data) {
      return await this.renderer.add(data);
    }
    /**
     * 从画布删除一个组件
     * @param data 组件信息数据
     */
    async remove(data) {
      return await this.renderer.remove(data);
    }
    setZoom(zoom = DEFAULT_ZOOM) {
      this.renderer.setZoom(zoom);
    }
    /**
     * 挂载Dom节点
     * @param el 将stage挂载到该Dom节点上
     */
    async mount(el) {
      this.container = el;
      const { mask, renderer } = this;
      await renderer.mount(el);
      mask.mount(el);
      this.emit("mounted");
    }
    /**
     * 清空所有参考线
     */
    clearGuides() {
      this.mask.clearGuides();
      this.actionManager.clearGuides();
    }
    /**
     * @deprecated 废弃接口，建议用delayedMarkContainer代替
     */
    getAddContainerHighlightClassNameTimeout(event, excludeElList = []) {
      return this.delayedMarkContainer(event, excludeElList);
    }
    /**
     * 鼠标拖拽着元素，在容器上方悬停，延迟一段时间后，对容器进行标记，如果悬停时间够长将标记成功，悬停时间短，调用方通过返回的timeoutId取消标记
     * 标记的作用：1、高亮容器，给用户一个加入容器的交互感知；2、释放鼠标后，通过标记的标志找到要加入的容器
     * @param event 鼠标事件
     * @param excludeElList 计算鼠标所在容器时要排除的元素列表
     * @returns timeoutId，调用方在鼠标移走时要取消该timeout，阻止标记
     */
    delayedMarkContainer(event, excludeElList = []) {
      return this.actionManager.delayedMarkContainer(event, excludeElList);
    }
    getMoveableOption(key) {
      return this.actionManager.getMoveableOption(key);
    }
    getDragStatus() {
      return this.actionManager.getDragStatus();
    }
    /**
     * 销毁实例
     */
    destroy() {
      const { mask, renderer, actionManager, pageResizeObserver } = this;
      renderer.destroy();
      mask.destroy();
      actionManager.destroy();
      pageResizeObserver?.disconnect();
      this.removeAllListeners();
      this.container = void 0;
    }
    /**
     * 监听页面大小变化
     */
    observePageResize(page) {
      if (typeof ResizeObserver !== "undefined") {
        this.pageResizeObserver = new ResizeObserver((entries) => {
          this.mask.pageResize(entries);
          this.actionManager.updateMoveable();
        });
        this.pageResizeObserver.observe(page);
      }
    }
    getActionManagerConfig(config) {
      const actionManagerConfig = {
        containerHighlightClassName: config.containerHighlightClassName,
        containerHighlightDuration: config.containerHighlightDuration,
        containerHighlightType: config.containerHighlightType,
        moveableOptions: config.moveableOptions,
        container: this.mask.content,
        disabledDragStart: config.disabledDragStart,
        canSelect: config.canSelect,
        isContainer: config.isContainer,
        updateDragEl: config.updateDragEl,
        getRootContainer: () => this.container,
        getRenderDocument: () => this.renderer.getDocument(),
        getTargetElement: (idOrEl) => this.renderer.getTargetElement(idOrEl),
        getElementsFromPoint: (point) => this.renderer.getElementsFromPoint(point)
      };
      return actionManagerConfig;
    }
    initRenderEvent() {
      this.renderer.on("runtime-ready", (runtime) => {
        this.emit("runtime-ready", runtime);
      });
      this.renderer.on("page-el-update", (el) => {
        this.mask?.observe(el);
        this.observePageResize(el);
      });
    }
    initMaskEvent() {
      this.mask.on("change-guides", (data) => {
        this.actionManager.setGuidelines(data.type, data.guides);
        this.emit("change-guides", data);
      });
    }
    /**
     * 初始化操作相关事件监听
     */
    initActionEvent() {
      this.initActionManagerEvent();
      this.initDrEvent();
      this.initMulDrEvent();
      this.initHighlightEvent();
      this.initMouseEvent();
    }
    /**
     * 初始化ActionManager类本身抛出来的事件监听
     */
    initActionManagerEvent() {
      this.actionManager.on("before-select", (idOrEl, event) => {
        this.select(idOrEl, event);
      }).on("select", (selectedEl) => {
        this.emit("select", selectedEl);
      }).on("before-multi-select", (idOrElList) => {
        this.multiSelect(idOrElList);
      }).on("multi-select", (selectedElList) => {
        this.emit("multi-select", selectedElList);
      });
    }
    /**
     * 初始化DragResize类通过ActionManager抛出来的事件监听
     */
    initDrEvent() {
      this.actionManager.on("update", (data) => {
        this.emit("update", data);
      }).on("sort", (data) => {
        this.emit("sort", data);
      }).on("select-parent", () => {
        this.emit("select-parent");
      }).on("remove", (data) => {
        this.emit("remove", data);
      });
    }
    /**
     * 初始化MultiDragResize类通过ActionManager抛出来的事件监听
     */
    initMulDrEvent() {
      this.actionManager.on("change-to-select", (el) => {
        this.select(el);
        setTimeout(() => this.emit("select", el));
      }).on("multi-update", (data) => {
        this.emit("update", data);
      });
    }
    /**
     * 初始化Highlight类通过ActionManager抛出来的事件监听
     */
    initHighlightEvent() {
      this.actionManager.on("highlight", async (highlightEl) => {
        this.emit("highlight", highlightEl);
      });
    }
    /**
     * 初始化Highlight类通过ActionManager抛出来的事件监听
     */
    initMouseEvent() {
      this.actionManager.on("mousemove", (event) => {
        this.emit("mousemove", event);
      }).on("mouseleave", (event) => {
        this.emit("mouseleave", event);
      }).on("drag-start", (e) => {
        this.emit("drag-start", e);
      });
    }
  }

  exports.AbleActionEventType = AbleActionEventType;
  exports.CONTAINER_HIGHLIGHT_CLASS_NAME = CONTAINER_HIGHLIGHT_CLASS_NAME;
  exports.ContainerHighlightType = ContainerHighlightType;
  exports.DEFAULT_ZOOM = DEFAULT_ZOOM;
  exports.DRAG_EL_ID_PREFIX = DRAG_EL_ID_PREFIX;
  exports.GHOST_EL_ID_PREFIX = GHOST_EL_ID_PREFIX;
  exports.GuidesType = GuidesType;
  exports.HIGHLIGHT_EL_ID_PREFIX = HIGHLIGHT_EL_ID_PREFIX;
  exports.Mode = Mode;
  exports.MouseButton = MouseButton;
  exports.PAGE_CLASS = PAGE_CLASS;
  exports.SELECTED_CLASS = SELECTED_CLASS;
  exports.SelectStatus = SelectStatus;
  exports.StageDragResize = StageDragResize;
  exports.StageDragStatus = StageDragStatus;
  exports.StageMask = StageMask;
  exports.StageRender = StageRender;
  exports.ZIndex = ZIndex;
  exports.addSelectedClassName = addSelectedClassName;
  exports.calcValueByFontsize = calcValueByFontsize;
  exports.default = StageCore;
  exports.down = down;
  exports.getAbsolutePosition = getAbsolutePosition;
  exports.getMode = getMode;
  exports.getOffset = getOffset;
  exports.getScrollParent = getScrollParent;
  exports.getTargetElStyle = getTargetElStyle;
  exports.isAbsolute = isAbsolute;
  exports.isFixed = isFixed;
  exports.isFixedParent = isFixedParent;
  exports.isMoveableButton = isMoveableButton;
  exports.isRelative = isRelative;
  exports.isStatic = isStatic;
  exports.removeSelectedClassName = removeSelectedClassName;
  exports.up = up;

  Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: 'Module' } });

}));
//# sourceMappingURL=tmagic-stage.umd.cjs.map
