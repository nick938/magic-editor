"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveAppPackages = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const path_1 = tslib_1.__importDefault(require("path"));
const process_1 = require("process");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const recast = tslib_1.__importStar(require("recast"));
const types_1 = require("../types");
const logger_1 = require("./logger");
const isFile = (filePath) => fs_extra_1.default.existsSync(filePath) && fs_extra_1.default.lstatSync(filePath).isFile();
const isDirectory = (filePath) => fs_extra_1.default.existsSync(filePath) && fs_extra_1.default.lstatSync(filePath).isDirectory();
const getRelativePath = (str, base) => (path_1.default.isAbsolute(str) ? path_1.default.relative(base, str) : str);
const npmInstall = function (dependencies, cwd, npmConfig = {}) {
    try {
        const { client = 'npm', registry } = npmConfig;
        const install = {
            npm: 'install',
            yarn: 'add',
            pnpm: 'add',
        }[client];
        const packages = Object.entries(dependencies)
            .map(([name, version]) => (version ? `${name}@${version}` : name))
            .join(' ');
        const command = `${client} ${install} ${packages}${registry ? ` --registry ${registry}` : ''}`;
        (0, logger_1.execInfo)(cwd);
        (0, logger_1.execInfo)(command);
        (0, child_process_1.execSync)(command, {
            stdio: 'inherit',
            cwd,
        });
    }
    catch (e) {
        (0, logger_1.error)(e);
    }
};
/**
 *  1 判断是否组件&插件&数据源包
 *  2 判断是组件还是插件还是数据源
 *  3 组件插件数据源分开写入 comp-entry.ts
 *
 *  export default 是对象字面量并且有install方法则为插件
 *
 *  export default 是类并且superClass为DataSource则为数据源
 *
 *  其他情况为组件或者包
 *
 * @param {*} ast
 * @param {String} indexPath
 * @return {Object} { type: '', imports: [] } 返回传入组件的类型。如果是组件包，imports 中包含所有子组件的入口文件路径
 */
const typeAssertion = function ({ ast, indexPath, componentFileAffix }) {
    const n = recast.types.namedTypes;
    const result = {
        type: '',
        imports: [],
    };
    const { importDeclarations, variableDeclarations, exportDefaultName, exportDefaultNode, exportDefaultClass } = getAssertionTokenByTraverse(ast);
    if (exportDefaultName) {
        importDeclarations.every((node) => {
            const [specifier] = node.specifiers;
            const defaultFile = getIndexPath(path_1.default.resolve(path_1.default.dirname(indexPath), node.source.value));
            if (componentFileAffix && !['.js', '.ts'].includes(componentFileAffix)) {
                if (node.source.value?.endsWith(componentFileAffix) || isFile(`${defaultFile}${componentFileAffix}`)) {
                    result.type = types_1.PackageType.COMPONENT;
                    return false;
                }
            }
            if (isFile(defaultFile)) {
                const defaultCode = fs_extra_1.default.readFileSync(defaultFile, { encoding: 'utf-8', flag: 'r' });
                const ast = recast.parse(defaultCode, { parser: require('recast/parsers/typescript') });
                if (isDatasource(ast.program.body.find((node) => node.type === 'ExportDefaultDeclaration')?.declaration)) {
                    result.type = types_1.PackageType.DATASOURCE;
                    return false;
                }
            }
            // 从 import 语句中找到 export default 的变量，认为是组件
            if (n.ImportDefaultSpecifier.check(specifier) && specifier.local?.name === exportDefaultName) {
                result.type = types_1.PackageType.COMPONENT;
                return false;
            }
            return true;
        });
        if (result.type)
            return result;
        variableDeclarations.every((node) => {
            const [variable] = node.declarations;
            // 从声明变量语句中找到 export default 的变量，认为是组件包
            if (n.Identifier.check(variable.id) &&
                variable.id.name === exportDefaultName &&
                n.ObjectExpression.check(variable.init)) {
                if (isPlugin(variable.init.properties)) {
                    result.type = types_1.PackageType.PLUGIN;
                    return false;
                }
                // 从组件包声明中找到对应子组件入口文件
                getComponentPackageImports({ result, properties: variable.init.properties, indexPath, importDeclarations });
            }
            return true;
        });
    }
    if (exportDefaultNode) {
        if (isPlugin(exportDefaultNode.properties)) {
            result.type = types_1.PackageType.PLUGIN;
        }
        else {
            getComponentPackageImports({
                result,
                properties: exportDefaultNode.properties,
                indexPath,
                importDeclarations,
            });
        }
    }
    if (isDatasource(exportDefaultClass)) {
        result.type = types_1.PackageType.DATASOURCE;
    }
    return result;
};
const getAssertionTokenByTraverse = (ast) => {
    const importDeclarations = [];
    const variableDeclarations = [];
    const n = recast.types.namedTypes;
    let exportDefaultName = '';
    let exportDefaultNode = undefined;
    let exportDefaultClass = undefined;
    recast.types.visit(ast, {
        visitImportDeclaration(p) {
            importDeclarations.push(p.node);
            this.traverse(p);
        },
        visitVariableDeclaration(p) {
            variableDeclarations.push(p.node);
            this.traverse(p);
        },
        visitExportDefaultDeclaration(p) {
            const { node } = p;
            const { declaration } = node;
            // 导出的是变量名
            if (n.Identifier.check(declaration)) {
                exportDefaultName = declaration.name;
            }
            // 导出的是对象的字面量
            if (n.ObjectExpression.check(declaration)) {
                exportDefaultNode = declaration;
            }
            // 导出的是类
            if (n.ClassDeclaration.check(declaration)) {
                exportDefaultClass = declaration;
            }
            this.traverse(p);
        },
    });
    return {
        importDeclarations,
        variableDeclarations,
        exportDefaultName,
        exportDefaultNode,
        exportDefaultClass,
    };
};
const isPlugin = function (properties) {
    const [match] = properties.filter((property) => property.key.name === 'install');
    return !!match;
};
const isDatasource = (exportDefaultClass) => exportDefaultClass?.superClass?.name === 'DataSource';
const getComponentPackageImports = function ({ result, properties, indexPath, importDeclarations, }) {
    const n = recast.types.namedTypes;
    result.type = types_1.PackageType.COMPONENT_PACKAGE;
    result.imports = [];
    properties.forEach((property) => {
        const [propertyMatch] = importDeclarations.filter((i) => {
            const [specifier] = i.specifiers;
            if (n.ImportDefaultSpecifier.check(specifier) && specifier.local?.name === property.value.name) {
                return true;
            }
            return false;
        });
        if (propertyMatch) {
            result.imports.push({
                type: property.key.name ?? property.key.value,
                name: propertyMatch.specifiers[0].local.name,
                indexPath: getIndexPath(path_1.default.resolve(path_1.default.dirname(indexPath), propertyMatch.source.value)),
            });
        }
    });
    return result;
};
const getIndexPath = function (entry) {
    for (const affix of ['', '.js', '.ts']) {
        const filePath = `${entry}${affix}`;
        if (isFile(filePath)) {
            return filePath;
        }
    }
    if (isDirectory(entry)) {
        const files = fs_extra_1.default.readdirSync(entry);
        const [index] = files.filter((file) => file.split('.')[0] === 'index');
        return path_1.default.resolve(entry, index);
    }
    return entry;
};
const parseEntry = function ({ ast, package: module, indexPath }) {
    if (!ast.program) {
        (0, logger_1.error)(`${module} 入口文件不合法`);
        (0, process_1.exit)(1);
    }
    const tokens = getASTTokenByTraverse({ ast, indexPath });
    let { config, value, event, component } = tokens;
    if (!config) {
        (0, logger_1.info)(`${module} 表单配置文件声明缺失`);
    }
    if (!value) {
        (0, logger_1.info)(`${module} 初始化数据文件声明缺失`);
    }
    if (!event) {
        (0, logger_1.info)(`${module} 事件声明文件声明缺失`);
    }
    if (!component) {
        (0, logger_1.info)(`${module} 组件或数据源文件声明不合法`);
        (0, process_1.exit)(1);
    }
    const reg = /^.*[/\\]node_modules[/\\](.*)/;
    [, config] = config.match(reg) || [, config];
    [, value] = value.match(reg) || [, value];
    [, component] = component.match(reg) || [, component];
    [, event] = event.match(reg) || [, event];
    return {
        config,
        value,
        component,
        event,
    };
};
const getASTTokenByTraverse = ({ ast, indexPath }) => {
    let config = '';
    let value = '';
    let event = '';
    let component = '';
    const importSpecifiersMap = {};
    const exportSpecifiersMap = {};
    recast.types.visit(ast, {
        visitImportDeclaration(p) {
            const { node } = p;
            const { specifiers, source } = node;
            if (specifiers?.length === 1 && source.value) {
                const name = specifiers?.[0].local?.name;
                if (name) {
                    importSpecifiersMap[name] = source.value;
                }
            }
            this.traverse(p);
        },
        visitExportNamedDeclaration(p) {
            const { node } = p;
            const { specifiers, source, declaration } = node;
            if (specifiers?.length === 1 && source?.value) {
                const name = specifiers?.[0]?.exported.name.toLowerCase();
                if (name) {
                    exportSpecifiersMap[name] = source.value;
                }
            }
            else {
                specifiers?.forEach((specifier) => {
                    const name = specifier.exported.name.toLowerCase();
                    exportSpecifiersMap[name] = undefined;
                });
                declaration?.declarations.forEach((declare) => {
                    const { id, init } = declare;
                    const { name } = id;
                    exportSpecifiersMap[name] = init.name;
                });
            }
            this.traverse(p);
        },
        visitExportDefaultDeclaration(p) {
            const { node } = p;
            const { declaration } = node;
            component = path_1.default.resolve(path_1.default.dirname(indexPath), importSpecifiersMap[declaration.name]);
            this.traverse(p);
        },
    });
    Object.keys(exportSpecifiersMap).forEach((exportName) => {
        const exportValue = exportSpecifiersMap[exportName];
        const importValue = importSpecifiersMap[exportName];
        const connectValue = exportValue ? importSpecifiersMap[exportValue] : '';
        const filePath = path_1.default.resolve(path_1.default.dirname(indexPath), connectValue || importValue || exportValue || '');
        if (exportName === types_1.EntryType.VALUE) {
            value = filePath;
        }
        else if (exportName === types_1.EntryType.CONFIG) {
            config = filePath;
        }
        else if (exportName === types_1.EntryType.EVENT) {
            event = filePath;
        }
        else if (exportName === 'default') {
            component = component || filePath;
        }
    });
    return {
        config,
        value,
        event,
        component,
    };
};
const splitNameVersion = function (str) {
    if (typeof str !== 'string') {
        return {};
    }
    if (fs_extra_1.default.existsSync(str)) {
        return {
            name: str,
            version: '',
        };
    }
    const packStr = String.prototype.trim.call(str);
    const ret = packStr.match(/((^|@).+)@(.+)/);
    let name = packStr;
    let version = 'latest';
    if (ret && ret[3] !== '') {
        ({ 1: name, 3: version } = ret);
    }
    return {
        name,
        version,
    };
};
const getDependencies = (dependencies, packagePath) => {
    if (fs_extra_1.default.existsSync(packagePath))
        return;
    const { name: moduleName, version } = splitNameVersion(packagePath);
    if (!moduleName)
        return;
    dependencies[moduleName] = version;
};
const setPackages = (packages, app, packagePath, key) => {
    const { options } = app;
    const { temp, source, componentFileAffix } = options;
    let { name: moduleName } = splitNameVersion(packagePath);
    if (!moduleName)
        throw Error('packages中包含非法配置');
    if (isDirectory(moduleName)) {
        if (!fs_extra_1.default.existsSync(path_1.default.join(moduleName, './package.json'))) {
            ['index.js', 'index.ts'].forEach((index) => {
                const indexFile = path_1.default.join(moduleName, `./${index}`);
                if (fs_extra_1.default.existsSync(indexFile)) {
                    moduleName = indexFile;
                    return;
                }
            });
        }
    }
    // 获取完整路径
    const indexPath = (0, child_process_1.execSync)(`node -e "console.log(require.resolve('${moduleName.replace(/\\/g, '/')}'))"`, {
        cwd: source,
    })
        .toString()
        .replace('\n', '');
    const indexCode = fs_extra_1.default.readFileSync(indexPath, { encoding: 'utf-8', flag: 'r' });
    const ast = recast.parse(indexCode, { parser: require('recast/parsers/typescript') });
    const result = typeAssertion({ ast, indexPath, componentFileAffix });
    // 组件&插件&数据源包
    if (result.type === types_1.PackageType.COMPONENT_PACKAGE) {
        result.imports.forEach((i) => {
            setPackages(packages, app, i.indexPath, i.type);
        });
        return;
    }
    if (!key)
        return;
    if (result.type === types_1.PackageType.COMPONENT) {
        // 组件
        const entry = parseEntry({ ast, package: moduleName, indexPath });
        if (entry.component)
            packages.componentMap[key] = getRelativePath(entry.component, temp);
        if (entry.config)
            packages.configMap[key] = getRelativePath(entry.config, temp);
        if (entry.event)
            packages.eventMap[key] = getRelativePath(entry.event, temp);
        if (entry.value)
            packages.valueMap[key] = getRelativePath(entry.value, temp);
    }
    else if (result.type === types_1.PackageType.DATASOURCE) {
        // 数据源
        const entry = parseEntry({ ast, package: moduleName, indexPath });
        if (entry.component)
            packages.datasourceMap[key] = getRelativePath(entry.component, temp);
        if (entry.config)
            packages.dsConfigMap[key] = getRelativePath(entry.config, temp);
        if (entry.event)
            packages.dsEventMap[key] = getRelativePath(entry.event, temp);
        if (entry.value)
            packages.dsValueMap[key] = getRelativePath(entry.value, temp);
    }
    else if (result.type === types_1.PackageType.PLUGIN) {
        // 插件
        packages.pluginMap[key] = getRelativePath(moduleName, temp);
    }
};
const flattenPackagesConfig = (packages) => {
    const packagesConfig = [];
    packages.forEach((item) => {
        if (typeof item === 'object') {
            Object.entries(item).forEach(([key, packagePath]) => {
                packagesConfig.push([packagePath, key]);
            });
        }
        else if (typeof item === 'string') {
            packagesConfig.push([item]);
        }
    });
    return packagesConfig;
};
const resolveAppPackages = (app) => {
    const dependencies = {};
    const { packages = [], npmConfig = {}, source } = app.options;
    const packagePaths = flattenPackagesConfig(packages);
    packagePaths.forEach(([packagePath]) => getDependencies(dependencies, packagePath));
    if (npmConfig.autoInstall && Object.keys(dependencies).length) {
        if (!npmConfig.keepPackageJsonClean) {
            npmInstall(dependencies, source, npmConfig);
        }
        else {
            const packageFile = path_1.default.join(source, 'package.json');
            const packageBakFile = path_1.default.join(source, 'package.json.bak');
            if (fs_extra_1.default.existsSync(packageFile)) {
                fs_extra_1.default.copyFileSync(packageFile, packageBakFile);
            }
            npmInstall(dependencies, source, npmConfig);
            if (fs_extra_1.default.existsSync(packageBakFile)) {
                fs_extra_1.default.unlinkSync(packageFile);
                fs_extra_1.default.renameSync(packageBakFile, packageFile);
            }
        }
    }
    const packagesMap = {
        componentMap: {},
        configMap: {},
        eventMap: {},
        valueMap: {},
        pluginMap: {},
        datasourceMap: {},
        dsConfigMap: {},
        dsEventMap: {},
        dsValueMap: {},
    };
    packagePaths.forEach(([packagePath, key]) => setPackages(packagesMap, app, packagePath, key));
    return packagesMap;
};
exports.resolveAppPackages = resolveAppPackages;
//# sourceMappingURL=resolveAppPackages.js.map