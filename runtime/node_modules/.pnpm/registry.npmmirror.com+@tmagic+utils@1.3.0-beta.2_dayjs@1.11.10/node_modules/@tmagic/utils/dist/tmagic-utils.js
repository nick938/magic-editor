import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';
import { NodeType } from '@tmagic/schema';

const asyncLoadJs = (() => {
  const documentMap = /* @__PURE__ */ new Map();
  return (url, crossOrigin, document = globalThis.document) => {
    let loaded = documentMap.get(document);
    if (!loaded) {
      loaded = /* @__PURE__ */ new Map();
      documentMap.set(document, loaded);
    }
    if (loaded.get(url))
      return loaded.get(url);
    const load = new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.type = "text/javascript";
      if (crossOrigin) {
        script.crossOrigin = crossOrigin;
      }
      script.src = url;
      document.body.appendChild(script);
      script.onload = () => {
        resolve();
      };
      script.onerror = () => {
        reject(new Error("加载失败"));
      };
      setTimeout(() => {
        reject(new Error("timeout"));
      }, 60 * 1e3);
    }).catch((err) => {
      loaded.delete(url);
      throw err;
    });
    loaded.set(url, load);
    return loaded.get(url);
  };
})();
const asyncLoadCss = (() => {
  const documentMap = /* @__PURE__ */ new Map();
  return (url, document = globalThis.document) => {
    let loaded = documentMap.get(document);
    if (!loaded) {
      loaded = /* @__PURE__ */ new Map();
      documentMap.set(document, loaded);
    }
    if (loaded.get(url))
      return loaded.get(url);
    const load = new Promise((resolve, reject) => {
      const node = document.createElement("link");
      node.rel = "stylesheet";
      node.href = url;
      document.head.appendChild(node);
      node.onload = () => {
        resolve();
      };
      node.onerror = () => {
        reject(new Error("加载失败"));
      };
      setTimeout(() => {
        reject(new Error("timeout"));
      }, 60 * 1e3);
    }).catch((err) => {
      loaded.delete(url);
      throw err;
    });
    loaded.set(url, load);
    return loaded.get(url);
  };
})();
const addClassName = (el, doc, className) => {
  const oldEl = doc.querySelector(`.${className}`);
  if (oldEl && oldEl !== el)
    removeClassName(oldEl, className);
  if (!el.classList.contains(className))
    el.classList.add(className);
};
const removeClassName = (el, className) => {
  el.classList.remove(className);
};
const removeClassNameByClassName = (doc, className) => {
  const el = doc.querySelector(`.${className}`);
  el?.classList.remove(className);
  return el;
};
const injectStyle = (doc, style) => {
  const styleEl = doc.createElement("style");
  styleEl.innerHTML = style;
  doc.head.appendChild(styleEl);
  return styleEl;
};
const createDiv = ({ className, cssText }) => {
  const el = globalThis.document.createElement("div");
  el.className = className;
  el.style.cssText = cssText;
  return el;
};
const getDocument = () => globalThis.document;

dayjs.extend(utc);
const sleep = (ms) => new Promise((resolve) => {
  const timer = setTimeout(() => {
    clearTimeout(timer);
    resolve();
  }, ms);
});
const datetimeFormatter = (v, defaultValue = "-", format = "YYYY-MM-DD HH:mm:ss") => {
  if (v) {
    let time = null;
    if (["x", "timestamp"].includes(format)) {
      time = dayjs(v).valueOf();
    } else if (typeof v === "string" && v.includes("Z") || v.constructor === Date) {
      time = dayjs(v).utcOffset(8).format(format);
    } else {
      time = dayjs(v).format(format);
    }
    if (time !== "Invalid Date") {
      return time;
    }
    return defaultValue;
  }
  return defaultValue;
};
const toLine = (name = "") => name.replace(/\B([A-Z])/g, "-$1").toLowerCase();
const toHump = (name = "") => name.replace(/-(\w)/g, (all, letter) => letter.toUpperCase());
const emptyFn = () => void 0;
const getNodePath = (id, data = []) => {
  const path = [];
  const get = function(id2, data2) {
    if (!Array.isArray(data2)) {
      return null;
    }
    for (let i = 0, l = data2.length; i < l; i++) {
      const item = data2[i];
      path.push(item);
      if (`${item.id}` === `${id2}`) {
        return item;
      }
      if (item.items) {
        const node = get(id2, item.items);
        if (node) {
          return node;
        }
      }
      path.pop();
    }
    return null;
  };
  get(id, data);
  return path;
};
const filterXSS = (str) => str.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
const getUrlParam = (param, url) => {
  const u = url || location.href;
  const reg = new RegExp(`[?&#]${param}=([^&#]+)`, "gi");
  const matches = u.match(reg);
  let strArr;
  if (matches && matches.length > 0) {
    strArr = matches[matches.length - 1].split("=");
    if (strArr && strArr.length > 1) {
      return filterXSS(strArr[1]);
    }
    return "";
  }
  return "";
};
const isObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
const isPop = (node) => Boolean(node?.type?.toLowerCase().endsWith("pop"));
const isPage = (node) => {
  if (!node)
    return false;
  return Boolean(node.type?.toLowerCase() === NodeType.PAGE);
};
const isNumber = (value) => /^(-?\d+)(\.\d+)?$/.test(value);
const getHost = (targetUrl) => targetUrl.match(/\/\/([^/]+)/)?.[1];
const isSameDomain = (targetUrl = "", source = globalThis.location.host) => {
  const isHttpUrl = /^(http[s]?:)?\/\//.test(targetUrl);
  if (!isHttpUrl)
    return true;
  return getHost(targetUrl) === source;
};
const guid = (digit = 8) => "x".repeat(digit).replace(/[xy]/g, (c) => {
  const r = Math.random() * 16 | 0;
  const v = c === "x" ? r : r & 3 | 8;
  return v.toString(16);
});
const getValueByKeyPath = (keys, value = {}) => {
  const path = keys.split(".");
  const pathLength = path.length;
  return path.reduce((accumulator, currentValue, currentIndex) => {
    if (Object.prototype.toString.call(accumulator) === "[object Object]" || Array.isArray(accumulator)) {
      return accumulator[currentValue];
    }
    if (pathLength - 1 === currentIndex) {
      return void 0;
    }
    return {};
  }, value);
};
const getNodes = (ids, data = []) => {
  const nodes = [];
  const get = function(ids2, data2) {
    if (!Array.isArray(data2)) {
      return;
    }
    for (let i = 0, l = data2.length; i < l; i++) {
      const item = data2[i];
      const index = ids2.findIndex((id) => `${id}` === `${item.id}`);
      if (index > -1) {
        ids2.slice(index, 1);
        nodes.push(item);
      }
      if (item.items) {
        get(ids2, item.items);
      }
    }
  };
  get(ids, data);
  return nodes;
};
const getDepKeys = (dataSourceDeps = {}, nodeId) => Array.from(
  Object.values(dataSourceDeps).reduce((prev, cur) => {
    (cur[nodeId]?.keys || []).forEach((key) => prev.add(key));
    return prev;
  }, /* @__PURE__ */ new Set())
);
const getDepNodeIds = (dataSourceDeps = {}) => Array.from(
  Object.values(dataSourceDeps).reduce((prev, cur) => {
    Object.keys(cur).forEach((id) => {
      prev.add(id);
    });
    return prev;
  }, /* @__PURE__ */ new Set())
);
const replaceChildNode = (newNode, data, parentId) => {
  const path = getNodePath(newNode.id, data);
  const node = path.pop();
  let parent = path.pop();
  if (parentId) {
    parent = getNodePath(parentId, data).pop();
  }
  if (!node)
    throw new Error("未找到目标节点");
  if (!parent)
    throw new Error("未找到父节点");
  const index = parent.items?.findIndex((child) => child.id === node.id);
  parent.items.splice(index, 1, newNode);
};
const compiledNode = (compile, node, dataSourceDeps = {}, sourceId) => {
  let keys = [];
  if (!sourceId) {
    keys = getDepKeys(dataSourceDeps, node.id);
  } else {
    const dep = dataSourceDeps[sourceId];
    keys = dep?.[node.id].keys || [];
  }
  const keyPrefix = "__magic__";
  keys.forEach((key) => {
    const keyPath = `${key}`.split(".");
    const keyPathLength = keyPath.length;
    keyPath.reduce((accumulator, currentValue, currentIndex) => {
      if (keyPathLength - 1 === currentIndex) {
        const cacheKey = `${keyPrefix}${currentValue}`;
        if (typeof accumulator[cacheKey] === "undefined") {
          accumulator[cacheKey] = accumulator[currentValue];
        }
        try {
          accumulator[currentValue] = compile(accumulator[cacheKey]);
        } catch (e) {
          console.error(e);
          accumulator[currentValue] = "";
        }
        return accumulator;
      }
      if (Object.prototype.toString.call(accumulator) === "[object Object]" || Array.isArray(accumulator)) {
        return accumulator[currentValue];
      }
      return {};
    }, node);
  });
  if (Array.isArray(node.items)) {
    node.items.forEach((item) => compiledNode(compile, item, dataSourceDeps));
  }
  return node;
};
const compiledCond = (op, fieldValue, value, range) => {
  switch (op) {
    case "is":
      if (!fieldValue)
        return false;
      break;
    case "not":
      if (fieldValue)
        return false;
      break;
    case "=":
      if (fieldValue !== value)
        return false;
      break;
    case "!=":
      if (fieldValue === value)
        return false;
      break;
    case ">":
      if (fieldValue <= value)
        return false;
      break;
    case ">=":
      if (fieldValue < value)
        return false;
      break;
    case "<":
      if (fieldValue >= value)
        return false;
      break;
    case "<=":
      if (fieldValue > value)
        return false;
      break;
    case "between":
      if (fieldValue < range[0] || fieldValue > range[1])
        return false;
      break;
    case "not_between":
      if (fieldValue >= range[0] && fieldValue <= range[1])
        return false;
      break;
    case "include":
      if (typeof fieldValue !== "undefined" && !fieldValue.includes?.(value))
        return false;
      break;
    case "not_include":
      if (typeof fieldValue !== "undefined" && fieldValue.includes?.(value))
        return false;
      break;
  }
  return true;
};

export { addClassName, asyncLoadCss, asyncLoadJs, compiledCond, compiledNode, createDiv, datetimeFormatter, emptyFn, filterXSS, getDepKeys, getDepNodeIds, getDocument, getHost, getNodePath, getNodes, getUrlParam, getValueByKeyPath, guid, injectStyle, isNumber, isObject, isPage, isPop, isSameDomain, removeClassName, removeClassNameByClassName, replaceChildNode, sleep, toHump, toLine };
//# sourceMappingURL=tmagic-utils.js.map
