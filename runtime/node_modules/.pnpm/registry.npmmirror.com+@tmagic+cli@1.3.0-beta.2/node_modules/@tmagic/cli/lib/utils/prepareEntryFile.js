"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeCamelCase = exports.prettyCode = exports.prepareEntryFile = void 0;
const tslib_1 = require("tslib");
const recast = tslib_1.__importStar(require("recast"));
const types_1 = require("../types");
const prepareEntryFile = async (app) => {
    const { moduleMainFilePath, options } = app;
    const { componentFileAffix, dynamicImport, hooks, useTs } = options;
    let contentMap = {
        'comp-entry': generateContent(useTs, types_1.EntryType.COMPONENT, moduleMainFilePath.componentMap, componentFileAffix),
        'async-comp-entry': generateContent(useTs, types_1.EntryType.COMPONENT, moduleMainFilePath.componentMap, componentFileAffix, dynamicImport),
        'plugin-entry': generateContent(useTs, types_1.EntryType.PLUGIN, moduleMainFilePath.pluginMap),
        'async-plugin-entry': generateContent(useTs, types_1.EntryType.PLUGIN, moduleMainFilePath.pluginMap, '', dynamicImport),
        'config-entry': generateContent(useTs, types_1.EntryType.CONFIG, moduleMainFilePath.configMap),
        'value-entry': generateContent(useTs, types_1.EntryType.VALUE, moduleMainFilePath.valueMap),
        'event-entry': generateContent(useTs, types_1.EntryType.EVENT, moduleMainFilePath.eventMap),
        'datasource-entry': generateContent(useTs, types_1.EntryType.DATASOURCE, moduleMainFilePath.datasourceMap),
        'ds-config-entry': generateContent(useTs, types_1.EntryType.DS_CONFIG, moduleMainFilePath.dsConfigMap),
        'ds-value-entry': generateContent(useTs, types_1.EntryType.DS_VALUE, moduleMainFilePath.dsValueMap),
        'ds-event-entry': generateContent(useTs, types_1.EntryType.DS_EVENT, moduleMainFilePath.dsEventMap),
    };
    if (typeof hooks?.beforeWriteEntry === 'function') {
        contentMap = await hooks.beforeWriteEntry(contentMap, app);
    }
    Object.entries(contentMap).forEach(([file, content]) => {
        let fileName = `${file}.ts`;
        if (useTs) {
            app.writeTemp(fileName, content);
        }
        else {
            fileName = `${file}.js`;
            app.writeTemp(`${file}.d.ts`, `const type: Record<string, any>;\n\nexport default type;`);
        }
        app.writeTemp(fileName, content);
    });
};
exports.prepareEntryFile = prepareEntryFile;
const generateContent = (useTs, type, map = {}, componentFileAffix = '', dynamicImport = false) => {
    const list = [];
    const importDeclarations = [];
    Object.entries(map).forEach(([key, packagePath]) => {
        const name = (0, exports.makeCamelCase)(key);
        if (dynamicImport) {
            list.push(`'${key}': () => import('${packagePath}${packagePath.endsWith(componentFileAffix) ? '' : componentFileAffix}')`);
        }
        else {
            importDeclarations.push(`import ${name} from '${packagePath}${packagePath.endsWith(componentFileAffix) ? '' : componentFileAffix}'`);
            list.push(`'${key}': ${name}`);
        }
    });
    const exportToken = `${type}s`;
    return (0, exports.prettyCode)(`${importDeclarations.join(';')}
    const ${exportToken}${useTs ? ': Record<string, any>' : ''} = {
      ${list.join(',')}
    }
    export default ${exportToken};
  `);
};
const prettyCode = (code) => recast.prettyPrint(recast.parse(code.replace(/\\/g, '/'), { parser: require('recast/parsers/typescript') }), {
    tabWidth: 2,
    trailingComma: true,
    quote: 'single',
}).code;
exports.prettyCode = prettyCode;
const makeCamelCase = function (name) {
    if (typeof name !== 'string') {
        return '';
    }
    return name.replace(/-(\w)/g, ($0, $1) => $1.toUpperCase());
};
exports.makeCamelCase = makeCamelCase;
//# sourceMappingURL=prepareEntryFile.js.map