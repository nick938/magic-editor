import EventEmitter from 'events';
import { template, cloneDeep, union } from 'lodash-es';
import { getValueByKeyPath, compiledNode, compiledCond, getNodes, getDepNodeIds, replaceChildNode } from '@tmagic/utils';

const getDefaultValueFromFields = (fields) => {
  const data = {};
  const defaultValue = {
    string: "",
    object: {},
    array: [],
    boolean: false,
    number: 0,
    null: null,
    any: void 0
  };
  fields.forEach((field) => {
    if (typeof field.defaultValue !== "undefined") {
      data[field.name] = field.defaultValue;
    } else if (field.type === "object") {
      data[field.name] = field.fields ? getDefaultValueFromFields(field.fields) : {};
    } else if (field.type) {
      data[field.name] = defaultValue[field.type];
    } else {
      data[field.name] = void 0;
    }
  });
  return data;
};

class DataSource extends EventEmitter {
  type = "base";
  id;
  isInit = false;
  data = {};
  app;
  fields = [];
  methods = [];
  constructor(options) {
    super();
    this.app = options.app;
    this.id = options.schema.id;
    this.setFields(options.schema.fields);
    this.setMethods(options.schema.methods || []);
    this.updateDefaultData();
  }
  setFields(fields) {
    this.fields = fields;
  }
  setMethods(methods) {
    this.methods = methods;
  }
  getMethods() {
    return this.methods;
  }
  setData(data) {
    this.data = data;
    this.emit("change");
  }
  getDefaultData() {
    return getDefaultValueFromFields(this.fields);
  }
  updateDefaultData() {
    this.setData(this.getDefaultData());
  }
  async init() {
    this.isInit = true;
  }
  destroy() {
    this.data = {};
    this.fields = [];
    this.removeAllListeners();
  }
}

const urlencoded = (data) => Object.entries(data).reduce((prev, [key, value]) => {
  let v = value;
  if (typeof value === "object") {
    v = JSON.stringify(value);
  }
  if (typeof value !== "undefined") {
    return `${prev}${prev ? "&" : ""}${globalThis.encodeURIComponent(key)}=${globalThis.encodeURIComponent(`${v}`)}`;
  }
  return prev;
}, "");
const webRequest = async (options) => {
  const { url, method = "GET", headers = {}, params = {}, data = {}, ...config } = options;
  const query = urlencoded(params);
  let body = JSON.stringify(data);
  if (headers["Content-Type"]?.includes("application/x-www-form-urlencoded")) {
    body = urlencoded(data);
  }
  const response = await globalThis.fetch(query ? `${url}?${query}` : url, {
    method,
    headers,
    body: method === "GET" ? void 0 : body,
    ...config
  });
  return response.json();
};
class HttpDataSource extends DataSource {
  type = "http";
  isLoading = false;
  error;
  schema;
  httpOptions;
  fetch;
  beforeRequest = [];
  afterRequest = [];
  constructor(options) {
    const { options: httpOptions, ...dataSourceOptions } = options.schema;
    super({
      schema: dataSourceOptions,
      app: options.app
    });
    this.schema = options.schema;
    this.httpOptions = httpOptions;
    if (typeof options.request === "function") {
      this.fetch = options.request;
    } else if (typeof globalThis.fetch === "function") {
      this.fetch = webRequest;
    }
    this.getMethods().forEach((method) => {
      if (typeof method.content !== "function")
        return;
      if (method.timing === "beforeRequest") {
        this.beforeRequest.push(method.content);
      }
      if (method.timing === "afterRequest") {
        this.afterRequest.push(method.content);
      }
    });
  }
  async init() {
    if (this.schema.autoFetch) {
      await this.request(this.httpOptions);
    }
    super.init();
  }
  async request(options) {
    try {
      for (const method of this.beforeRequest) {
        await method({ options, params: {}, dataSource: this, app: this.app });
      }
      const res = await this.fetch?.({
        ...this.httpOptions,
        ...options
      });
      for (const method of this.afterRequest) {
        await method({ res, options, params: {}, dataSource: this, app: this.app });
      }
      if (this.schema.responseOptions?.dataPath) {
        const data = getValueByKeyPath(this.schema.responseOptions.dataPath, res);
        this.setData(data);
      } else {
        this.setData(res);
      }
      this.error = void 0;
    } catch (error) {
      this.error = {
        msg: error.message
      };
      this.emit("error", error);
    }
  }
  get(options) {
    return this.request({
      ...options,
      method: "GET"
    });
  }
  post(options) {
    return this.request({
      ...options,
      method: "POST"
    });
  }
}

class DataSourceManager extends EventEmitter {
  static dataSourceClassMap = /* @__PURE__ */ new Map();
  static registe(type, dataSource) {
    DataSourceManager.dataSourceClassMap.set(type, dataSource);
  }
  static getDataSourceClass(type) {
    return DataSourceManager.dataSourceClassMap.get(type);
  }
  app;
  dataSourceMap = /* @__PURE__ */ new Map();
  data = {};
  constructor({ app }) {
    super();
    this.app = app;
    app.dsl?.dataSources?.forEach((config) => {
      this.addDataSource(config);
    });
  }
  get(id) {
    return this.dataSourceMap.get(id);
  }
  async addDataSource(config) {
    if (!config)
      return;
    let ds;
    if (config.type === "http") {
      ds = new HttpDataSource({
        app: this.app,
        schema: config,
        request: this.app.request
      });
    } else {
      const DataSourceClass = DataSourceManager.dataSourceClassMap.get(config.type) || DataSource;
      ds = new DataSourceClass({
        app: this.app,
        schema: config
      });
    }
    this.dataSourceMap.set(config.id, ds);
    this.data[ds.id] = ds.data;
    const beforeInit = [];
    const afterInit = [];
    ds.getMethods().forEach((method) => {
      if (typeof method.content !== "function")
        return;
      if (method.timing === "beforeInit") {
        beforeInit.push(method.content);
      }
      if (method.timing === "afterInit") {
        afterInit.push(method.content);
      }
    });
    for (const method of beforeInit) {
      await method({ params: {}, dataSource: ds, app: this.app });
    }
    await ds.init();
    for (const method of afterInit) {
      await method({ params: {}, dataSource: ds, app: this.app });
    }
    this.setData(ds);
    ds.on("change", () => {
      this.setData(ds);
    });
  }
  setData(ds) {
    Object.assign(this.data[ds.id], ds.data);
    this.emit("change", ds.id);
  }
  removeDataSource(id) {
    this.get(id)?.destroy();
    delete this.data[id];
    this.dataSourceMap.delete(id);
  }
  updateSchema(schemas) {
    schemas.forEach((schema) => {
      const ds = this.dataSourceMap.get(schema.id);
      if (!ds) {
        return;
      }
      ds.setFields(schema.fields);
      ds.updateDefaultData();
      this.data[ds.id] = ds.data;
    });
  }
  compiledNode(node, sourceId) {
    if (node.condResult === false)
      return node;
    if (node.visible === false)
      return node;
    return compiledNode(
      (value) => {
        if (typeof value === "string") {
          return template(value)(this.data);
        }
        if (value?.isBindDataSource && value.dataSourceId) {
          return this.data[value.dataSourceId];
        }
        return value;
      },
      cloneDeep(node),
      this.app.dsl?.dataSourceDeps || {},
      sourceId
    );
  }
  compliedConds(node) {
    if (!node.displayConds || !Array.isArray(node.displayConds) || !node.displayConds.length)
      return true;
    for (const { cond } of node.displayConds) {
      if (!cond)
        continue;
      let result = true;
      for (const { op, value, range, field } of cond) {
        const [sourceId, fieldKey] = field;
        const dsData = this.data[sourceId];
        if (!dsData || !fieldKey) {
          break;
        }
        const fieldValue = dsData[fieldKey];
        if (!compiledCond(op, fieldValue, value, range)) {
          result = false;
          break;
        }
      }
      if (result) {
        return true;
      }
    }
    return false;
  }
  destroy() {
    this.removeAllListeners();
    this.data = {};
    this.dataSourceMap.forEach((ds) => {
      ds.destroy();
    });
    this.dataSourceMap = /* @__PURE__ */ new Map();
  }
}
const DataSourceManager$1 = DataSourceManager;

const createDataSourceManager = (app) => {
  const { dsl, platform } = app;
  if (!dsl?.dataSources)
    return;
  const dataSourceManager = new DataSourceManager$1({ app });
  if (dsl.dataSources && dsl.dataSourceCondDeps && platform !== "editor") {
    getNodes(getDepNodeIds(dsl.dataSourceCondDeps), dsl.items).forEach((node) => {
      node.condResult = dataSourceManager.compliedConds(node);
      replaceChildNode(node, dsl.items);
    });
  }
  if (dsl.dataSources && dsl.dataSourceDeps) {
    getNodes(getDepNodeIds(dsl.dataSourceDeps), dsl.items).forEach((node) => {
      replaceChildNode(dataSourceManager.compiledNode(node), dsl.items);
    });
  }
  dataSourceManager.on("change", (sourceId) => {
    const dep = dsl.dataSourceDeps?.[sourceId] || {};
    const condDep = dsl.dataSourceCondDeps?.[sourceId] || {};
    const nodeIds = union([...Object.keys(condDep), ...Object.keys(dep)]);
    dataSourceManager.emit(
      "update-data",
      getNodes(nodeIds, dsl.items).map((node) => {
        const newNode = cloneDeep(node);
        newNode.condResult = dataSourceManager.compliedConds(node);
        return dataSourceManager.compiledNode(newNode);
      }),
      sourceId
    );
  });
  return dataSourceManager;
};

export { DataSource, DataSourceManager$1 as DataSourceManager, HttpDataSource, createDataSourceManager, getDefaultValueFromFields };
//# sourceMappingURL=tmagic-data-source.js.map
